Menu="Utilities"
Title="Multi-Function LUKS Key Utility"
Icon="key"
---
<?
# Get CSRF token from Unraid's variable system
$csrf_token = $var['csrf_token'] ?? '';

# Get plugin version
$version_file = '/boot/config/plugins/luks-key-management/VERSION';
$version = file_exists($version_file) ? trim(file_get_contents($version_file)) : 'Unknown';
?>

<div style="color: #F15A2C; font-weight: bold; font-size: 12px; margin-bottom: 10px;">
Plugin Version: <?=$version?>
</div>

<div style="margin-bottom: 20px; color: var(--text-color);">
This plugin manages encrypted drives with tools for auto-unlock at boot, LUKS header backup, key changes, and viewing encryption slots and metadata. Choose which tool to use from the tabs below.
</div>

<style>
/* Status output container */
#statusOutput {
  padding: 15px;
  border-radius: 5px;
  border: 1px solid #ccc;
  min-height: 400px;
  max-height: 600px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
  font-family: 'Courier New', monospace;
  font-size: 12px;
  border: 1px solid #444;
}

/* Loading spinner styles */
.status-loading {
  text-align: center;
  padding: 15px;
  background: #2a2a2a;
  border-radius: 5px;
  margin: 10px 0;
  border: 1px solid #444;
}

.status-loading .spinner {
  margin: 0 auto 10px auto;
  width: 120px;
  height: 70px;
}

.status-loading .loading-message {
  color: #fff;
  font-size: 16px;
}

.description {
  font-size: 13px;
  opacity: 0.7;
  margin: 5px 0 0 0;
  line-height: 1.5;
  max-width: 600px;
}

/* Tab navigation - Custom orange styling */
.tab-nav {
  margin: 20px 0;
}

.tab-nav ul {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

.tab-nav li {
  margin: 0;
}

.tab-nav button {
  display: block;
  padding: 10px 20px;
  background: transparent;
  border: 2px solid #F15A2C;
  color: var(--text-color, #000);
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  text-decoration: none;
  border-radius: 6px;
  width: 270px;
  text-align: center;
  transition: all 0.2s ease;
  margin-bottom: 8px;
}

.tab-nav button:hover {
  background: rgba(241, 90, 44, 0.1);
  color: #F15A2C;
}

.tab-nav button.active {
  background: #F15A2C;
  border: 2px solid #F15A2C;
  color: #ffffff;
  font-weight: bold;
}

.tab-nav i {
  margin-right: 8px;
}

/* Tab content */
.tab-content {
  display: none;
  margin: 20px 0;
}

.tab-content.active {
  display: block;
}

.tab-content h2 {
  margin-top: 0;
  padding-top: 0;
  border-top: none;
  color: #F15A2C;
}

/* Standard button styling for consistency */
.tab-content button,
.tab-content input[type="submit"] {
  padding: 8px 16px;
  margin: 2px;
  min-width: 120px;
  font-size: 14px;
}

.tab-content button + button {
  margin-left: 8px;
}

</style>

<div class="tab-nav">
  <ul>
    <li><button onclick="showTab('auto-start')" id="tab-auto-start" class="active"><i class="fa fa-play"></i>Auto Start</button></li>
    <li><button onclick="showTab('luks-headers')" id="tab-luks-headers"><i class="fa fa-shield"></i>LUKS Headers</button></li>
    <li><button onclick="showTab('encryption-info')" id="tab-encryption-info"><i class="fa fa-info"></i>Encryption Info</button></li>
    <li><button onclick="showTab('status')" id="tab-status"><i class="fa fa-terminal"></i>Status</button></li>
  </ul>
</div>

<div id="content-auto-start" class="tab-content active">
  <h2><i class="fa fa-play"></i> Auto Start</h2>
  
  <p>This plugin manages LUKS auto-unlock using hardware keys. Manual unlock is always possible using your original passphrase.</p>
  
  <!-- Loading indicator -->
  <div id="smartStatusLoading" style="display: block; margin: 20px 0; padding: 10px; border-radius: 5px; border-left: 4px solid #F15A2C;">
    <strong>Loading system status...</strong>
  </div>
  
  <!-- Manual refresh option if smart detection fails -->
  <div id="manualRefreshOption" style="display: none; margin: 20px 0; padding: 15px; border-radius: 5px; border: 2px solid #ffa726; background-color: rgba(255, 167, 38, 0.1);">
    <h3 style="margin-top: 0; color: #ffa726;"><i class="fa fa-refresh"></i> Status Detection Issue</h3>
    <p>The automatic status detection encountered an issue. You can manually refresh the detection or proceed with setup.</p>
    
    <dl>
      <dt>&nbsp;</dt>
      <dd>
        <span><button type="button" onclick="loadSmartStatus()" style="background: #ffa726; color: white; padding: 10px 20px; margin-right: 10px;">Retry Detection</button></span>
        <span><button type="button" onclick="showSetupForm()">Manual Setup</button></span>
        <div class="description">If detection continues to fail, you can proceed with manual hardware key setup.</div>
      </dd>
    </dl>
  </div>
  
  <!-- State: Array Stopped -->
  <div id="stateArrayStopped" style="display: none;">
    <div style="margin: 20px 0; padding: 20px; border-radius: 8px; border: 2px solid #4dabf7; background-color: rgba(77, 171, 247, 0.1);">
      <h3 style="margin-top: 0; color: #4dabf7;"><i class="fa fa-info-circle"></i> Start Your Array First</h3>
      <p>The Unraid array must be started before using this plugin. LUKS encrypted devices need to be accessible for the plugin to work properly.</p>
      <p><strong>Why?</strong> The plugin needs to detect encrypted drives, verify hardware keys, and manage LUKS tokens - all of which require the array to be running.</p>
      
      <dl>
        <dt>&nbsp;</dt>
        <dd>
          <span><button type="button" onclick="goToDiskSettings()" style="background: #4dabf7; color: white; padding: 12px 24px; font-size: 16px; border: none; border-radius: 6px; cursor: pointer;">Go to Main Tab → Start Array</button></span>
          <div class="description">Start your array to enable LUKS device detection and key verification.</div>
        </dd>
      </dl>
    </div>
  </div>
  
  <!-- State: Setup Required -->
  <div id="stateSetupRequired" style="display: none;">
    <div style="margin: 20px 0; padding: 20px; border-radius: 8px; border: 2px solid #ff6b6b; background-color: rgba(255, 107, 107, 0.1);">
      <h3 style="margin-top: 0; color: #ff6b6b;"><i class="fa fa-exclamation-triangle"></i> Hardware Keys Required</h3>
      <p>Hardware keys required for auto-unlock.</p>
      
      <dl>
        <dt>&nbsp;</dt>
        <dd>
          <span><button type="button" onclick="showSetupForm()" style="background: #ff6b6b; color: white; padding: 12px 24px; font-size: 16px; border: none; border-radius: 6px; cursor: pointer;">Generate Hardware Keys</button></span>
          <div class="description">Generate hardware keys for auto-unlock functionality.</div>
        </dd>
      </dl>
    </div>
  </div>
  
  <!-- State: Ready but Disabled (Orange) -->
  <div id="stateReadyDisabled" style="display: none;">
    <div style="margin: 20px 0; padding: 20px; border-radius: 8px; border: 2px solid #ffa726; background-color: rgba(255, 167, 38, 0.1);">
      <h3 style="margin-top: 0; color: #ffa726;"><i class="fa fa-key"></i> Hardware Keys Ready</h3>
      <p>Hardware keys ready - auto-unlock disabled.</p>
      <p><strong>Unlockable Devices:</strong> <span id="unlockableDevicesDisabled">Loading...</span></p>
      
      <dl>
        <dt>&nbsp;</dt>
        <dd>
          <span><button type="button" onclick="toggleAutoUnlock(true)" style="background: #ffa726; color: white; padding: 12px 24px; font-size: 16px; border: none; border-radius: 6px; cursor: pointer;">Enable Auto-Unlock</button></span>
          <div class="description">Enable automatic LUKS unlock at boot.</div>
        </dd>
      </dl>
    </div>
  </div>
  
  <!-- State: Ready and Enabled (Green) -->
  <div id="stateReadyEnabled" style="display: none;">
    <div style="margin: 20px 0; padding: 20px; border-radius: 8px; border: 2px solid #51cf66; background-color: rgba(81, 207, 102, 0.1);">
      <h3 style="margin-top: 0; color: #51cf66;"><i class="fa fa-check-circle"></i> Auto-Unlock Active</h3>
      <p>Hardware keys will unlock devices at boot.</p>
      <p><strong>Unlockable Devices:</strong> <span id="unlockableDevicesEnabled">Loading...</span></p>
      
      <dl>
        <dt>&nbsp;</dt>
        <dd>
          <span><button type="button" onclick="toggleAutoUnlock(false)" style="background: #51cf66; color: white; padding: 12px 24px; font-size: 16px; border: none; border-radius: 6px; cursor: pointer;">Disable Auto-Unlock</button></span>
          <div class="description">Disable automatic LUKS unlock at boot.</div>
        </dd>
      </dl>
    </div>
  </div>
  
  <!-- State: No Encrypted Disks -->
  <div id="stateNoEncryptedDisks" style="display: none;">
    <div style="margin: 20px 0; padding: 20px; border-radius: 8px; border: 2px solid #ff6b6b; background-color: rgba(255, 107, 107, 0.1);">
      <h3 style="margin-top: 0; color: #ff6b6b;"><i class="fa fa-info-circle"></i> No Encrypted Disks Found</h3>
      <p>This plugin requires LUKS encrypted arrays or pools to function.</p>
      <p>Please encrypt your drives first using Unraid's disk encryption settings.</p>
    </div>
  </div>
  
  
  <!-- Setup Form (hidden by default) -->
  <div id="setupForm" style="display: none; margin-top: 20px;">
    <h3>Hardware Key Setup</h3>
    <p>Enter your existing LUKS encryption credentials to generate hardware keys:</p>
    
    <!-- Progress card for setup form feedback -->
    <div id="setupFormMessage" style="display: none; margin: 20px 0; padding: 20px; border-radius: 8px; background-color: #ffc107; color: #000; font-size: 16px; font-weight: 500; text-align: center; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border: 2px solid #e0a800;">
      <div id="setupFormSpinner" style="margin-bottom: 15px;">
        <i class="fa fa-spinner fa-spin" style="font-size: 28px; color: #000; margin-right: 10px;"></i>
        <i class="fa fa-cogs" style="font-size: 20px; color: #000; opacity: 0.7;"></i>
      </div>
      <div id="setupFormText">Generating hardware keys and downloading LUKS headers. Please wait...</div>
    </div>
    
    <form id="autostartForm">
      <dl>
        <dt>Existing Encryption Key</dt>
        <dd>
          <select id="keyType_autostart" class="short" onchange="toggleKeyInput('autostart')">
            <option value="passphrase" selected>Passphrase</option>
            <option value="keyfile">Keyfile</option>
          </select>
        </dd>
      </dl>
      
      <div id="passphraseSection_autostart">
        <dl>
          <dt>Enter Existing Passphrase</dt>
          <dd>
            <input type="password" id="passphrase_autostart" name="passphrase" class="short" maxlength="512" required>
            <label><input type="checkbox" onchange="togglePasswordVisibility('autostart')"> show passphrase</label>
            <div class="description">Enter your original LUKS encryption passphrase.</div>
          </dd>
        </dl>
      </div>
      
      <div id="keyfileSection_autostart" style="display: none;">
        <dl>
          <dt>Select Existing Keyfile</dt>
          <dd>
            <input type="file" id="keyfile_autostart" name="keyfile" onchange="validateKeyfileSize(this, 'autostart')">
            <div class="description">Select your original LUKS encryption keyfile. Maximum size: 8 MiB. Any file type accepted.</div>
          </dd>
        </dl>
        
        <dl>
          <dt>Backup ZIP Password</dt>
          <dd>
            <input type="password" id="zipPassword_autostart" class="short" maxlength="512">
            <label style="margin-left: 10px;"><input type="checkbox" id="showZipPassword_autostart" onchange="togglePasswordVisibility('autostart')"> Show password</label>
            <div class="description">Password to encrypt the LUKS headers backup ZIP file. Required for keyfile authentication.</div>
          </dd>
        </dl>
      </div>
      
      <dl>
        <dt>Header Backup Location</dt>
        <dd>
          <select id="backupLocation" name="backupLocation" class="short" onchange="updateBackupLocationDescription()">
            <option value="download" selected>Download to PC</option>
            <option value="yes">Save to boot device</option>
          </select>
          <div class="description" id="backupLocationDescription">LUKS headers will always be backed up for safety. Files will be downloaded to your browser's download folder.</div>
        </dd>
      </dl>
      
      <dl>
        <dt>Dry Run</dt>
        <dd>
          <select id="dryRun" name="dryRun" class="short">
            <option value="no" selected>No - Apply changes</option>
            <option value="yes">Yes - Simulate only</option>
          </select>
          <div class="description">Choose 'Yes' to preview actions without making changes, or 'No' to execute the setup.</div>
        </dd>
      </dl>
      
      <dl>
        <dt>&nbsp;</dt>
        <dd>
          <span><input type="submit" value="SETUP AND ENABLE" onclick="runAutoStartSetup(); return false;"></span>
          <span><button type="button" onclick="hideSetupForm()" style="margin-left: 10px;">Cancel</button></span>
        </dd>
      </dl>
    </form>
  </div>
</div>

<div id="content-luks-headers" class="tab-content">
  <h2><i class="fa fa-shield"></i> LUKS Headers</h2>
  
  <!-- Array Stopped Message for Headers Tab -->
  <div id="headersArrayStoppedMessage" style="display: none;">
    <div style="margin: 20px 0; padding: 20px; border-radius: 8px; border: 2px solid #4dabf7; background-color: rgba(77, 171, 247, 0.1);">
      <h3 style="margin-top: 0; color: #4dabf7;"><i class="fa fa-info-circle"></i> Start Your Array First</h3>
      <p>The Unraid array must be started before using this plugin. LUKS encrypted devices need to be accessible for the plugin to work properly.</p>
      <p><strong>Why?</strong> The plugin needs to detect encrypted drives, verify hardware keys, and manage LUKS tokens - all of which require the array to be running.</p>
      
      <dl>
        <dt>&nbsp;</dt>
        <dd>
          <span><button type="button" onclick="goToDiskSettings()" style="background: #4dabf7; color: white; padding: 12px 24px; font-size: 16px; border: none; border-radius: 6px; cursor: pointer;">Go to Main Tab → Start Array</button></span>
          <div class="description">Start your array to enable LUKS device detection and key verification.</div>
        </dd>
      </dl>
    </div>
  </div>
  
  <!-- No Encrypted Disks Message for Headers Tab -->
  <div id="headersNoDisksMessage" style="display: none;">
    <div style="margin: 20px 0; padding: 20px; border-radius: 8px; border: 2px solid #ff6b6b; background-color: rgba(255, 107, 107, 0.1);">
      <h3 style="margin-top: 0; color: #ff6b6b;"><i class="fa fa-info-circle"></i> No Encrypted Disks Found</h3>
      <p>This plugin requires LUKS encrypted arrays or pools to function.</p>
      <p>Please encrypt your drives first using Unraid's disk encryption settings.</p>
    </div>
  </div>
  
  <!-- Normal Headers Content -->
  <div id="headersNormalContent">
    <p>Create backups of your LUKS headers for all devices that your authentication method can unlock. These backups are essential for recovery if headers become corrupted.</p>
    
    <p><strong>Backup Security:</strong> When using passphrase authentication, header backups are encrypted with your LUKS passphrase. When using keyfile authentication, you can provide a custom password to encrypt the backup ZIP file for security.</p>
  </div>
  
  <form id="headersForm" style="display: block;">
    <h3>Backup LUKS Headers</h3>
    
    <dl>
      <dt>Existing Encryption Key</dt>
      <dd>
        <select id="keyType_headers" class="short" onchange="toggleKeyInput('headers')">
          <option value="passphrase" selected>Passphrase</option>
          <option value="keyfile">Keyfile</option>
        </select>
      </dd>
    </dl>
    
    <div id="passphraseSection_headers">
      <dl>
        <dt>Enter Existing Passphrase</dt>
        <dd>
          <input type="password" id="passphrase_headers" name="passphrase" class="short" maxlength="512" required>
          <label><input type="checkbox" onchange="togglePasswordVisibility('headers')"> show passphrase</label>
          <div class="description">Enter your LUKS encryption key. All devices this passphrase unlocks will be backed up.</div>
        </dd>
      </dl>
    </div>
    
    <div id="keyfileSection_headers" style="display: none;">
      <dl>
        <dt>Select Existing Keyfile</dt>
        <dd>
          <input type="file" id="keyfile_headers" name="keyfile" onchange="validateKeyfileSize(this, 'headers')">
          <div class="description">Select your LUKS encryption keyfile. All devices this keyfile unlocks will be backed up. Maximum size: 8 MiB. Any file type accepted.</div>
        </dd>
      </dl>
      
      <dl>
        <dt>Backup ZIP Password</dt>
        <dd>
          <input type="password" id="zipPassword_headers" class="short" maxlength="512">
          <label style="margin-left: 10px;"><input type="checkbox" id="showZipPassword_headers" onchange="togglePasswordVisibility('headers')"> Show password</label>
          <div class="description">Password to encrypt the LUKS headers backup ZIP file. Required for keyfile authentication.</div>
        </dd>
      </dl>
    </div>
    
    <dl>
      <dt>Header Backup Location</dt>
      <dd>
        <select id="headersBackupLocation" name="headersBackupLocation" class="short" onchange="updateHeadersBackupLocationDescription()">
          <option value="yes">Save to boot device</option>
          <option value="download" selected>Download to PC</option>
        </select>
        <div class="description" id="headersBackupLocationDescription">Choose to save the encrypted backup on the server or download it to your computer.</div>
      </dd>
    </dl>
    
    <dl>
      <dt>&nbsp;</dt>
      <dd>
        <span><button type="button" onclick="runHeadersBackup()">Backup Headers</button></span>
      </dd>
    </dl>
  </form>
</div>


<div id="content-encryption-info" class="tab-content">
  <h2><i class="fa fa-info"></i> Encryption Info</h2>
  
  <!-- Array Stopped Message for Encryption Info Tab -->
  <div id="encinfoArrayStoppedMessage" style="display: none;">
    <div style="margin: 20px 0; padding: 20px; border-radius: 8px; border: 2px solid #4dabf7; background-color: rgba(77, 171, 247, 0.1);">
      <h3 style="margin-top: 0; color: #4dabf7;"><i class="fa fa-info-circle"></i> Start Your Array First</h3>
      <p>The Unraid array must be started before using this plugin. LUKS encrypted devices need to be accessible for the plugin to work properly.</p>
      <p><strong>Why?</strong> The plugin needs to detect encrypted drives, verify hardware keys, and manage LUKS tokens - all of which require the array to be running.</p>
      
      <dl>
        <dt>&nbsp;</dt>
        <dd>
          <span><button type="button" onclick="goToDiskSettings()" style="background: #4dabf7; color: white; padding: 12px 24px; font-size: 16px; border: none; border-radius: 6px; cursor: pointer;">Go to Main Tab → Start Array</button></span>
          <div class="description">Start your array to enable LUKS device detection and key verification.</div>
        </dd>
      </dl>
    </div>
  </div>
  
  <!-- No Encrypted Disks Message for Encryption Info Tab -->
  <div id="encinfoNoDisksMessage" style="display: none;">
    <div style="margin: 20px 0; padding: 20px; border-radius: 8px; border: 2px solid #ff6b6b; background-color: rgba(255, 107, 107, 0.1);">
      <h3 style="margin-top: 0; color: #ff6b6b;"><i class="fa fa-info-circle"></i> No Encrypted Disks Found</h3>
      <p>This plugin requires LUKS encrypted arrays or pools to function.</p>
      <p>Please encrypt your drives first using Unraid's disk encryption settings.</p>
    </div>
  </div>
  
  <!-- Normal Encryption Info Content -->
  <div id="encinfoNormalContent">
    <p>View detailed information about LUKS encryption on your server. This provides insight into encrypted drives, slot usage, and key configurations.</p>
  </div>
  
  <form id="encinfoForm" style="display: block;">
    <h3>Encryption Analysis</h3>
    
    <dl>
      <dt>Existing Encryption Key</dt>
      <dd>
        <select id="keyType_encinfo" class="short" onchange="toggleKeyInput('encinfo')">
          <option value="passphrase" selected>Passphrase</option>
          <option value="keyfile">Keyfile</option>
        </select>
      </dd>
    </dl>
    
    <div id="passphraseSection_encinfo">
      <dl>
        <dt>Enter Existing Passphrase</dt>
        <dd>
          <input type="password" id="passphrase_encinfo" name="passphrase" class="short" maxlength="512" required>
          <label><input type="checkbox" onchange="togglePasswordVisibility('encinfo')"> show passphrase</label>
          <div class="description">Enter your LUKS encryption key to analyze encrypted drives and slots.</div>
        </dd>
      </dl>
    </div>
    
    <div id="keyfileSection_encinfo" style="display: none;">
      <dl>
        <dt>Select Existing Keyfile</dt>
        <dd>
          <input type="file" id="keyfile_encinfo" name="keyfile" onchange="validateKeyfileSize(this, 'encinfo')">
          <div class="description">Select your LUKS encryption keyfile to analyze encrypted drives and slots. Maximum size: 8 MiB. Any file type accepted.</div>
        </dd>
      </dl>
    </div>
    
    <dl>
      <dt>Detail Level</dt>
      <dd>
        <select id="detailLevel" name="detailLevel" class="short">
          <option value="simple" selected>Simple (drive list only)</option>
          <option value="detailed">Detailed (smart grouping with slots and metadata)</option>
          <option value="very_detailed">Very Detailed (individual device analysis)</option>
        </select>
        <div class="description">Choose how much information to display about your encrypted drives.</div>
      </dd>
    </dl>
    
    <dl>
      <dt>&nbsp;</dt>
      <dd>
        <span>
          <button type="button" onclick="runEncryptionInfo()">View Encryption Status</button>
          <button type="button" onclick="downloadEncryptionInfo()">Download Analysis</button>
        </span>
      </dd>
    </dl>
  </form>
  
  <div style="margin-top: 15px; padding: 10px; border-radius: 5px; border-left: 4px solid #FF9800;">
    <strong>Security Note:</strong> Your passphrase is required to access LUKS metadata. This is read-only analysis and makes no changes to your encryption configuration.
  </div>
</div>

<div id="content-status" class="tab-content">
  <h2><i class="fa fa-terminal"></i> Status</h2>
  
  <!-- Array Stopped Message for Status Tab -->
  <div id="statusArrayStoppedMessage" style="display: none;">
    <div style="margin: 20px 0; padding: 20px; border-radius: 8px; border: 2px solid #4dabf7; background-color: rgba(77, 171, 247, 0.1);">
      <h3 style="margin-top: 0; color: #4dabf7;"><i class="fa fa-info-circle"></i> Start Your Array First</h3>
      <p>The Unraid array must be started before using this plugin. LUKS encrypted devices need to be accessible for the plugin to work properly.</p>
      <p><strong>Why?</strong> The plugin needs to detect encrypted drives, verify hardware keys, and manage LUKS tokens - all of which require the array to be running.</p>
      
      <dl>
        <dt>&nbsp;</dt>
        <dd>
          <span><button type="button" onclick="goToDiskSettings()" style="background: #4dabf7; color: white; padding: 12px 24px; font-size: 16px; border: none; border-radius: 6px; cursor: pointer;">Go to Main Tab → Start Array</button></span>
          <div class="description">Start your array to enable LUKS device detection and key verification.</div>
        </dd>
      </dl>
    </div>
  </div>
  
  <!-- No Encrypted Disks Message for Status Tab -->
  <div id="statusNoDisksMessage" style="display: none;">
    <div style="margin: 20px 0; padding: 20px; border-radius: 8px; border: 2px solid #ff6b6b; background-color: rgba(255, 107, 107, 0.1);">
      <h3 style="margin-top: 0; color: #ff6b6b;"><i class="fa fa-info-circle"></i> No Encrypted Disks Found</h3>
      <p>This plugin requires LUKS encrypted arrays or pools to function.</p>
      <p>Please encrypt your drives first using Unraid's disk encryption settings.</p>
    </div>
  </div>
  
  <!-- Normal Status Content -->
  <div id="statusNormalContent">
    <p>Operation output and status information will be displayed here. All plugin operations will automatically show their output in this section.</p>
    
    <h3>Current Operation Status</h3>
  </div>
  
  <dl>
    <dt>&nbsp;</dt>
    <dd>
      <span><button type="button" onclick="clearStatus()">Clear Output</button></span>
    </dd>
  </dl>

  <!-- Loading Spinner for status tab -->
  <div id="status-loading" style="display: none; text-align: center; padding: 15px; border-radius: 5px; margin: 10px 0; border: 1px solid #ccc;">
    <div class="spinner" style="margin: 0 auto 10px auto; width: 120px; height: 70px;"></div>
    <div id="loading-message" style="font-size: 16px;">Processing request...</div>
  </div>

  <!-- Main status output area -->
  <pre id="statusOutput" style="padding: 15px; border-radius: 5px; border: 1px solid #ccc; min-height: 400px; max-height: 600px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word; font-family: 'Courier New', monospace; font-size: 12px;">No operations performed yet. Output from all plugin operations will appear here.</pre>
</div>

<script>
  // TODO: Remove all console.log('DEBUG: ...') statements before final release
  
  // Make CSRF token available to JavaScript
  var csrf_token = '<?=$csrf_token?>';
  
  // Tab functionality
  function showTab(tabId) {
    console.log('DEBUG: Switching to tab:', tabId);
    
    // Hide all tab contents
    const allContents = document.querySelectorAll('.tab-content');
    allContents.forEach(content => {
      content.classList.remove('active');
    });
    
    // Remove active class from all tab buttons
    const allButtons = document.querySelectorAll('.tab-nav button');
    allButtons.forEach(button => {
      button.classList.remove('active');
    });
    
    // Show selected tab content
    const selectedContent = document.getElementById('content-' + tabId);
    if (selectedContent) {
      selectedContent.classList.add('active');
      console.log('DEBUG: Activated content for tab:', tabId);
    } else {
      console.error('DEBUG: Could not find content for tab:', tabId);
    }
    
    // Activate selected tab button
    const selectedButton = document.getElementById('tab-' + tabId);
    if (selectedButton) {
      selectedButton.classList.add('active');
      console.log('DEBUG: Activated button for tab:', tabId);
    } else {
      console.error('DEBUG: Could not find button for tab:', tabId);
    }
    
    // Check encrypted disks availability for this tab
    updateTabBasedOnEncryptedDisks(tabId);
  }
  
  // Function to check encrypted disks availability and show/hide content accordingly
  function updateTabBasedOnEncryptedDisks(tabId) {
    console.log('DEBUG: updateTabBasedOnEncryptedDisks called for tab:', tabId);
    
    // Skip auto-start tab as it has its own logic
    if (tabId === 'auto-start') {
      console.log('DEBUG: Skipping auto-start tab, has its own logic');
      return;
    }
    
    // Get system state to check for encrypted disks
    fetch('/plugins/luks-key-management/scripts/get_smart_status.php', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: 'csrf_token=' + encodeURIComponent(csrf_token)
    })
    .then(response => {
      console.log('DEBUG: Response status:', response.status);
      console.log('DEBUG: Response headers:', response.headers);
      return response.text().then(text => {
        console.log('DEBUG: Raw response text:', text);
        try {
          return JSON.parse(text);
        } catch (e) {
          console.error('DEBUG: JSON parse error:', e);
          console.error('DEBUG: Response was:', text);
          throw e;
        }
      });
    })
    .then(data => {
      const systemState = data.system_state;
      const arrayRunning = systemState !== 'array_stopped';
      const hasEncryptedDisks = systemState !== 'no_encrypted_disks';
      
      console.log('DEBUG: API response for tab', tabId, ':', data);
      console.log('DEBUG: System state:', systemState);
      console.log('DEBUG: Array running:', arrayRunning);
      console.log('DEBUG: Has encrypted disks:', hasEncryptedDisks);
      
      // Update each tab based on system state
      if (tabId === 'luks-headers') {
        console.log('DEBUG: Updating LUKS Headers tab');
        const arrayStoppedMsg = document.getElementById('headersArrayStoppedMessage');
        const noDisksMsg = document.getElementById('headersNoDisksMessage');
        const normalContent = document.getElementById('headersNormalContent');
        const form = document.getElementById('headersForm');
        
        // Hide all messages first
        if (arrayStoppedMsg) arrayStoppedMsg.style.display = 'none';
        if (noDisksMsg) noDisksMsg.style.display = 'none';
        if (normalContent) normalContent.style.display = 'none';
        if (form) form.style.display = 'none';
        
        // Show appropriate content based on state
        if (!arrayRunning) {
          if (arrayStoppedMsg) arrayStoppedMsg.style.display = 'block';
        } else if (!hasEncryptedDisks) {
          if (noDisksMsg) noDisksMsg.style.display = 'block';
        } else {
          if (normalContent) normalContent.style.display = 'block';
          if (form) form.style.display = 'block';
        }
        
        console.log('DEBUG: Headers elements found:', !!arrayStoppedMsg, !!noDisksMsg, !!normalContent, !!form);
        
      } else if (tabId === 'encryption-info') {
        console.log('DEBUG: Updating Encryption Info tab');
        const arrayStoppedMsg = document.getElementById('encinfoArrayStoppedMessage');
        const noDisksMsg = document.getElementById('encinfoNoDisksMessage');
        const normalContent = document.getElementById('encinfoNormalContent');
        const form = document.getElementById('encinfoForm');
        
        // Hide all messages first
        if (arrayStoppedMsg) arrayStoppedMsg.style.display = 'none';
        if (noDisksMsg) noDisksMsg.style.display = 'none';
        if (normalContent) normalContent.style.display = 'none';
        if (form) form.style.display = 'none';
        
        // Show appropriate content based on state
        if (!arrayRunning) {
          if (arrayStoppedMsg) arrayStoppedMsg.style.display = 'block';
        } else if (!hasEncryptedDisks) {
          if (noDisksMsg) noDisksMsg.style.display = 'block';
        } else {
          if (normalContent) normalContent.style.display = 'block';
          if (form) form.style.display = 'block';
        }
        
        console.log('DEBUG: Encinfo elements found:', !!arrayStoppedMsg, !!noDisksMsg, !!normalContent, !!form);
        
      } else if (tabId === 'status') {
        console.log('DEBUG: Updating Status tab');
        const arrayStoppedMsg = document.getElementById('statusArrayStoppedMessage');
        const noDisksMsg = document.getElementById('statusNoDisksMessage');
        const normalContent = document.getElementById('statusNormalContent');
        const clearButton = document.querySelector('#content-status dl');
        const statusOutput = document.getElementById('statusOutput');
        const statusLoading = document.getElementById('status-loading');
        
        // Hide all messages first
        if (arrayStoppedMsg) arrayStoppedMsg.style.display = 'none';
        if (noDisksMsg) noDisksMsg.style.display = 'none';
        if (normalContent) normalContent.style.display = 'none';
        if (clearButton) clearButton.style.display = 'none';
        if (statusOutput) statusOutput.style.display = 'none';
        if (statusLoading) statusLoading.style.display = 'none';
        
        // Show appropriate content based on state
        if (!arrayRunning) {
          if (arrayStoppedMsg) arrayStoppedMsg.style.display = 'block';
        } else if (!hasEncryptedDisks) {
          if (noDisksMsg) noDisksMsg.style.display = 'block';
        } else {
          if (normalContent) normalContent.style.display = 'block';
          if (clearButton) clearButton.style.display = 'block';
          if (statusOutput) statusOutput.style.display = 'block';
          if (statusLoading) statusLoading.style.display = 'block';
        }
        
        console.log('DEBUG: Status elements found:', !!arrayStoppedMsg, !!noDisksMsg, !!normalContent, !!clearButton, !!statusOutput, !!statusLoading);
      }
    })
    .catch(error => {
      console.error('DEBUG: Error checking encrypted disks:', error);
      // On error, default to showing normal content
    });
  }
  
  // Unified status output functions
  function updateStatus(message) {
    const statusOutput = document.getElementById('statusOutput');
    statusOutput.textContent += message + '\n';
    statusOutput.scrollTop = statusOutput.scrollHeight;
    
    // Auto-switch to status tab
    showTab('status');
  }

  function setStatus(message) {
    // Hide loading spinner when we get output
    hideStatusLoading();
    
    const statusOutput = document.getElementById('statusOutput');
    statusOutput.textContent = message + '\n';
    statusOutput.scrollTop = statusOutput.scrollHeight;
    
    // Auto-switch to status tab
    showTab('status');
  }

  function clearStatus() {
    hideStatusLoading();
    document.getElementById('statusOutput').textContent = 'Output cleared.\n';
  }

  // Clear status silently without any message (for operation starts)
  function clearStatusSilently() {
    hideStatusLoading();
    document.getElementById('statusOutput').textContent = '';
  }

  // Loading spinner control functions
  function showStatusLoading(message) {
    console.log('DEBUG: showStatusLoading called with message:', message);
    const loadingDiv = document.getElementById('status-loading');
    const loadingMessage = document.getElementById('loading-message');
    const spinnerDiv = loadingDiv.querySelector('.spinner');
    
    console.log('DEBUG: loadingDiv found:', !!loadingDiv);
    console.log('DEBUG: loadingMessage found:', !!loadingMessage);
    console.log('DEBUG: spinnerDiv found:', !!spinnerDiv);
    
    if (loadingDiv && loadingMessage && spinnerDiv) {
      loadingMessage.textContent = message || 'Processing...';
      
      // Use the official Unraid spinner animation
      if (typeof unraid_logo !== 'undefined') {
        spinnerDiv.innerHTML = unraid_logo;
      } else {
        // Fallback: try to use the same method as the main Unraid interface
        spinnerDiv.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 133.52 76.97" class="unraid_mark"><defs><linearGradient id="unraid_logo_plugin" x1="23.76" y1="81.49" x2="109.76" y2="-4.51" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#e32929"/><stop offset="1" stop-color="#ff8d30"/></linearGradient></defs><path d="m70,19.24zm57,0l6.54,0l0,38.49l-6.54,0l0,-38.49z" fill="url(#unraid_logo_plugin)" class="unraid_mark_9"/><path d="m70,19.24zm47.65,11.9l-6.55,0l0,-23.79l6.55,0l0,23.79z" fill="url(#unraid_logo_plugin)" class="unraid_mark_8"/><path d="m70,19.24zm31.77,-4.54l-6.54,0l0,-14.7l6.54,0l0,14.7z" fill="url(#unraid_logo_plugin)" class="unraid_mark_7"/><path d="m70,19.24zm15.9,11.9l-6.54,0l0,-23.79l6.54,0l0,23.79z" fill="url(#unraid_logo_plugin)" class="unraid_mark_6"/><path d="m63.49,19.24l6.51,0l0,38.49l-6.51,0l0,-38.49z" fill="url(#unraid_logo_plugin)" class="unraid_mark_5"/><path d="m70,19.24zm-22.38,26.6l6.54,0l0,23.78l-6.54,0l0,-23.78z" fill="url(#unraid_logo_plugin)" class="unraid_mark_4"/><path d="m70,19.24zm-38.26,43.03l6.55,0l0,14.73l-6.55,0l0,-14.73z" fill="url(#unraid_logo_plugin)" class="unraid_mark_3"/><path d="m70,19.24zm-54.13,26.6l6.54,0l0,23.78l-6.54,0l0,-23.78z" fill="url(#unraid_logo_plugin)" class="unraid_mark_2"/><path d="m70,19.24zm-63.46,38.49l-6.54,0l0,-38.49l6.54,0l0,38.49z" fill="url(#unraid_logo_plugin)" class="unraid_mark_1"/></svg>';
      }
      
      loadingDiv.style.display = 'block';
      console.log('DEBUG: Loading spinner should now be visible with official animation');
      
      // Auto-scroll to status section
      showTab('status');
    } else {
      console.log('DEBUG: Missing elements - loadingDiv:', !!loadingDiv, 'loadingMessage:', !!loadingMessage, 'spinnerDiv:', !!spinnerDiv);
    }
  }

  function hideStatusLoading() {
    const loadingDiv = document.getElementById('status-loading');
    if (loadingDiv) {
      loadingDiv.style.display = 'none';
    }
  }

  // Show spinner in setup form message area
  function showInCardSpinner() {
    const setupForm = document.getElementById('setupForm');
    if (setupForm && setupForm.style.display !== 'none') {
      const setupSpinner = document.getElementById('setupFormSpinner');
      if (setupSpinner) {
        setupSpinner.style.display = 'block';
      }
    }
  }

  // Hide spinner in setup form message area  
  function hideInCardSpinner() {
    const setupForm = document.getElementById('setupForm');
    if (setupForm && setupForm.style.display !== 'none') {
      const setupSpinner = document.getElementById('setupFormSpinner');
      if (setupSpinner) {
        setupSpinner.style.display = 'none';
      }
    }
  }

  // Show temporary message in current Auto Start state card
  function showInCardMessage(message, duration = 3000) {
    console.log('DEBUG: showInCardMessage called with:', message, 'duration:', duration);
    
    // Check if setup form is visible first
    const setupForm = document.getElementById('setupForm');
    if (setupForm && setupForm.style.display !== 'none') {
      console.log('DEBUG: Setup form visible, using setup form message area');
      const setupMessageArea = document.getElementById('setupFormMessage');
      const setupTextArea = document.getElementById('setupFormText');
      if (setupMessageArea && setupTextArea) {
        setupTextArea.textContent = message;
        setupMessageArea.style.display = 'block';
        
        // Auto-hide after specified time
        if (duration > 0) {
          setTimeout(function() {
            setupMessageArea.style.display = 'none';
          }, duration);
        }
        return;
      }
    }
    
    // Find the currently visible state card
    const stateCards = [
      document.getElementById('stateArrayStopped'),
      document.getElementById('stateSetupRequired'), 
      document.getElementById('stateReadyDisabled'),
      document.getElementById('stateReadyEnabled')
    ];
    
    let currentCard = null;
    for (const card of stateCards) {
      if (card && card.style.display !== 'none') {
        currentCard = card;
        break;
      }
    }
    
    if (!currentCard) {
      console.log('DEBUG: No visible state card found, falling back to status tab');
      updateStatus(message);
      return;
    }
    
    // Create or update in-card message area
    let messageArea = currentCard.querySelector('.in-card-message');
    if (!messageArea) {
      messageArea = document.createElement('div');
      messageArea.className = 'in-card-message';
      messageArea.style.cssText = 'margin-top: 10px; padding: 10px; border-radius: 4px; background-color: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; font-size: 14px;';
      currentCard.insertBefore(messageArea, currentCard.firstChild.nextSibling);
    }
    
    messageArea.textContent = message;
    messageArea.style.display = 'block';
    
    // Auto-hide after duration (unless duration is 0)
    if (duration > 0) {
      setTimeout(() => {
        if (messageArea && messageArea.parentNode) {
          messageArea.style.display = 'none';
        }
      }, duration);
    }
  }

  function runAutoStartSetup() {
    // Clear any previous status output
    clearStatusSilently();
    
    console.log('DEBUG: runAutoStartSetup called');
    
    // Show progress in current Auto Start tab instead of redirecting to status
    showInCardMessage('Starting auto-unlock setup...', 0); // 0 = don't auto-hide
    
    // Validate encryption key input using shared component
    const validationError = validateEncryptionKeyInput('autostart');
    console.log('DEBUG: Validation result:', validationError);
    if (validationError) {
      showInCardMessage('Error: ' + validationError, 5000);
      return;
    }
    
    const backupLocation = document.getElementById('backupLocation').value;
    const dryRun = document.getElementById('dryRun').value;

    // Show the prominent progress card with spinner
    showInCardMessage('Generating hardware keys and downloading LUKS headers. Please wait...', 0);
    showInCardSpinner();
    
    console.log('DEBUG: Status set, preparing form data');

    // Convert backupLocation to the format expected by the backend
    const backupHeaders = backupLocation === 'download' ? 'download' : 'yes';

    // Prepare data using Unraid's pattern (no FormData, use base64 for files)
    const keyType = document.getElementById('keyType_autostart').value;
    console.log('DEBUG: keyType:', keyType);
    
    const postData = {
      keyType: keyType,
      backupHeaders: backupHeaders,
      dryRun: dryRun
    };
    
    if (keyType === 'passphrase') {
      const passphrase = document.getElementById('passphrase_autostart').value;
      console.log('DEBUG: Using passphrase, length:', passphrase.length);
      postData.passphrase = passphrase;
    } else {
      const keyfileInput = document.getElementById('keyfile_autostart');
      console.log('DEBUG: Using keyfile, files:', keyfileInput.files);
      if (keyfileInput.files && keyfileInput.files[0]) {
        console.log('DEBUG: File selected:', keyfileInput.files[0].name, 'Size:', keyfileInput.files[0].size);
        
        // Add ZIP password for keyfile users
        const zipPassword = document.getElementById('zipPassword_autostart').value;
        postData.zipPassword = zipPassword;
        console.log('DEBUG: ZIP password included for keyfile user');
        
        // Convert file to base64 (Unraid pattern)
        const reader = new FileReader();
        reader.onload = function(e) {
          const base64Data = e.target.result; // This includes 'data:application/octet-stream;base64,'
          postData.keyfileData = base64Data;
          
          // Add CSRF token
          console.log('DEBUG: Using CSRF token:', csrf_token);
          if (csrf_token) {
            postData.csrf_token = csrf_token;
          }
          
          console.log('DEBUG: Starting AJAX request with base64 keyfile');
          makeAjaxRequest(postData, 'auto-start');
        };
        reader.readAsDataURL(keyfileInput.files[0]);
        return; // Exit here, the request will be made in the reader callback
      } else {
        console.log('DEBUG: No file selected!');
        showInCardMessage('Error: No keyfile selected', 5000);
        return;
      }
    }
    
    // Add CSRF token for passphrase requests
    console.log('DEBUG: Using CSRF token:', csrf_token);
    if (csrf_token) {
      postData.csrf_token = csrf_token;
    } else {
      console.log('WARNING: No CSRF token available');
    }

    console.log('DEBUG: Starting AJAX request to /plugins/luks-key-management/scripts/run_luks_script.php');
    makeAjaxRequest(postData, 'auto-start');
  }
  
  function makeAjaxRequest(postData, context = 'default') {
    $.ajax({
      url: '/plugins/luks-key-management/scripts/run_luks_script.php',
      type: 'POST',
      data: postData,
      beforeSend: function(xhr) {
        console.log('DEBUG: AJAX request starting...');
      },
      success: function(data) {
        console.log('DEBUG: AJAX success, response length:', data.length);
        console.log('DEBUG: Response data:', data);
        console.log('DEBUG: Context:', context);
        
        // Handle response based on context
        if (context === 'auto-start') {
          // For Auto Start operations, stay on Auto Start page with in-card messaging
          const isDryRun = document.getElementById('dryRun').value === 'yes';
          
          console.log('DEBUG: Auto-start response analysis:', {
            hasCheckmark: data.includes('✅'),
            hasSUCCESS: data.includes('SUCCESS'),
            hasCompletedSuccessfully: data.includes('completed successfully'),
            hasSetupCompleted: data.includes('Setup completed'),
            hasError: data.includes('Error:'),
            hasFailed: data.includes('Failed:'),
            dataLength: data.length,
            dataPreview: data.substring(0, 200)
          });
          
          if (data.includes('✅') || data.includes('SUCCESS') || data.includes('completed successfully') || data.includes('Setup completed')) {
            console.log('DEBUG: Success detected, transitioning to ready state');
            hideInCardSpinner();
            showInCardMessage('Setup completed successfully! Transitioning to next state...', 3000);
            
            // Hide setup form and refresh status after a short delay for smooth transition
            setTimeout(function() {
              hideSetupForm();
              loadSmartStatus(); // This will transition to the appropriate state card
            }, 2000);
          } else if (data.includes('Error:') || data.includes('Failed:')) {
            console.log('DEBUG: Error detected');
            // Show error in Auto Start card, don't redirect to Status tab
            hideInCardSpinner();
            const errorText = data.replace(/^.*Error:\s*/i, '').split('\n')[0]; // Extract first error line
            showInCardMessage('Error: ' + errorText, 8000); // Longer timeout for errors
          } else {
            console.log('DEBUG: Generic completion - treating as success');
            // For other messages, treat as success and transition
            hideInCardSpinner();
            showInCardMessage('Operation completed successfully! Transitioning to next state...', 3000);
            
            // Hide setup form and refresh status for state transition
            setTimeout(function() {
              hideSetupForm();
              loadSmartStatus();
            }, 2000);
          }
        } else {
          // For other tabs (headers, encryption-info), use original behavior
          showTab('status');
          setStatus(data);
        }
        
        // Use shared download detection function with context awareness
        const finalBackupLocation = document.getElementById('backupLocation').value;
        const finalDryRun = document.getElementById('dryRun').value;
        handleDownloadDetection(data, finalBackupLocation, finalDryRun, context);
      },
      error: function(xhr, status, error) {
        console.log('DEBUG: AJAX error - Status:', status, 'Error:', error);
        console.log('DEBUG: XHR object:', xhr);
        
        const errorMessage = 'Error: AJAX failed - Status: ' + status + ', Error: ' + error + '\nCheck browser console for more details.';
        
        if (context === 'auto-start') {
          // Stay on Auto Start page, show network error in card
          hideInCardSpinner();
          showInCardMessage('Network error: ' + status + ' - ' + error + '. Check browser console for details.', 8000);
        } else {
          // For other tabs, use original behavior
          showTab('status');
          setStatus(errorMessage);
        }
      }
    });
  }

  function downloadBackupFile(filename, context = 'default') {
    // Create direct download link - file is accessible via plugin downloads directory
    const downloadUrl = '/plugins/luks-key-management/downloads/' + filename;
    
    // Create a temporary anchor element to trigger download
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = filename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Context-aware messaging - don't redirect to Status tab for Auto Start operations
    if (context === 'auto-start') {
      console.log('DEBUG: Download initiated for Auto Start context, not redirecting to Status tab');
      // Download is silent for Auto Start operations, continue with current workflow
    } else {
      // For other contexts (headers, encryption-info), use original behavior
      updateStatus('\nBackup file download initiated. Check your browser\'s download folder.');
    }
    
    // Clean up the temporary file after a delay
    setTimeout(function() {
      fetch('/plugins/luks-key-management/scripts/cleanup_download.php', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'filename=' + encodeURIComponent(filename)
      });
    }, 5000); // 5 second delay to ensure download completes
  }

  // Event management functions for new plugin architecture
  function refreshAutoUnlockStatus() {
    console.log('DEBUG: refreshAutoUnlockStatus called');
    
    // Show status in the Auto Start tab itself
    showStatusInTab('Checking auto-unlock status...');
    
    const postData = { action: 'status' };
    if (csrf_token) {
      postData.csrf_token = csrf_token;
    }
    
    $.ajax({
      url: '/plugins/luks-key-management/scripts/run_event_script.php',
      type: 'POST',
      data: postData,
      success: function(data) {
        console.log('DEBUG: Status check response:', data);
        
        // Parse the response to extract status
        let statusText = "Unknown";
        if (data.includes('enabled')) {
          statusText = "Enabled ✅";
        } else if (data.includes('disabled')) {
          statusText = "Disabled ❌";
        }
        
        // Update the status display
        document.getElementById('autoUnlockStatus').textContent = statusText;
        
        // Show full output in the status area
        showStatusInTab(data);
      },
      error: function() {
        document.getElementById('autoUnlockStatus').textContent = "Error checking status";
        showStatusInTab('Error: Failed to check auto-unlock status');
      }
    });
  }
  
  function enableAutoUnlock() {
    console.log('DEBUG: enableAutoUnlock called');
    
    showStatusInTab('Enabling auto-unlock...');
    
    const postData = { action: 'enable' };
    if (csrf_token) {
      postData.csrf_token = csrf_token;
    }
    
    $.ajax({
      url: '/plugins/luks-key-management/scripts/run_event_script.php',
      type: 'POST',
      data: postData,
      success: function(data) {
        console.log('DEBUG: Enable response:', data);
        showStatusInTab(data);
        
        // Update status display after successful enable
        if (data.includes('enabled successfully')) {
          document.getElementById('autoUnlockStatus').textContent = "Enabled ✅";
        }
      },
      error: function() {
        showStatusInTab('Error: Failed to enable auto-unlock');
      }
    });
  }
  
  function disableAutoUnlock() {
    console.log('DEBUG: disableAutoUnlock called');
    
    showStatusInTab('Disabling auto-unlock...');
    
    const postData = { action: 'disable' };
    if (csrf_token) {
      postData.csrf_token = csrf_token;
    }
    
    $.ajax({
      url: '/plugins/luks-key-management/scripts/run_event_script.php',
      type: 'POST',
      data: postData,
      success: function(data) {
        console.log('DEBUG: Disable response:', data);
        showStatusInTab(data);
        
        // Update status display after successful disable
        if (data.includes('disabled successfully')) {
          document.getElementById('autoUnlockStatus').textContent = "Disabled ❌";
        }
      },
      error: function() {
        showStatusInTab('Error: Failed to disable auto-unlock');
      }
    });
  }
  
  // Helper function to show status within the current tab instead of switching to status tab
  function showStatusInTab(message) {
    let statusOutput = document.getElementById('statusOutput');
    
    // Update the status content (statusOutput is always visible in Status tab)
    statusOutput.textContent = message;
    statusOutput.scrollTop = statusOutput.scrollHeight;
    
    // Also show in Status tab for full output
    showTab('status');
  }

  function runHeadersBackup() {
    // Clear any previous status output
    clearStatusSilently();
    
    // Validate encryption key input using shared component
    const validationError = validateEncryptionKeyInput('headers');
    if (validationError) {
      setStatus('Error: ' + validationError);
      return;
    }

    const backupLocation = document.getElementById('headersBackupLocation').value;

    // Auto-scroll to Status section to show operation progress
    showTab('status');
    showStatusLoading('Backing up LUKS headers...');
    updateStatus('Starting LUKS headers backup operation...\nExecuting LUKS headers backup script, please wait...');

    // Use the same backend but with headers-only flags
    const backupMode = backupLocation === 'download' ? 'download' : 'yes';
    const keyType = document.getElementById('keyType_headers').value;
    
    // Prepare data using the same pattern as Auto Start (which works)
    const postData = {
      keyType: keyType,
      backupHeaders: backupMode,
      dryRun: 'no', // Headers backup is always live
      headersOnly: 'true' // Flag to indicate this is headers-only operation
    };
    
    if (keyType === 'passphrase') {
      const passphrase = document.getElementById('passphrase_headers').value;
      postData.passphrase = passphrase;
      
      // Add CSRF token
      if (csrf_token) {
        postData.csrf_token = csrf_token;
      }
      
      // Make request directly for passphrase
      makeHeadersAjaxRequest(postData, backupLocation);
    } else {
      const keyfileInput = document.getElementById('keyfile_headers');
      if (keyfileInput.files && keyfileInput.files[0]) {
        // Add ZIP password for keyfile users
        const zipPassword = document.getElementById('zipPassword_headers').value;
        postData.zipPassword = zipPassword;
        console.log('DEBUG: ZIP password included for headers keyfile user');
        
        // Convert file to base64 (same pattern as Auto Start)
        const reader = new FileReader();
        reader.onload = function(e) {
          const base64Data = e.target.result;
          postData.keyfileData = base64Data;
          
          // Add CSRF token
          if (csrf_token) {
            postData.csrf_token = csrf_token;
          }
          
          makeHeadersAjaxRequest(postData, backupLocation);
        };
        reader.readAsDataURL(keyfileInput.files[0]);
        return;
      } else {
        setStatus('Error: No keyfile selected');
        return;
      }
    }
  }
  
  function makeHeadersAjaxRequest(postData, backupLocation) {
    $.ajax({
      url: '/plugins/luks-key-management/scripts/run_luks_script.php',
      type: 'POST',
      data: postData,
      success: function(data) {
        // Always show output in Status tab
        showTab('status');
        setStatus(data);
        
        // Check if we need to download a backup file
        if (backupLocation === 'download') {
          const downloadMatch = data.match(/DOWNLOAD_READY: (.+)/);
          if (downloadMatch) {
            const downloadPath = downloadMatch[1];
            const filename = downloadPath.split('/').pop();
            downloadBackupFile(filename);
          }
        }
      },
      error: function() {
        setStatus('Error: Failed to execute the LUKS headers backup script. Check browser console for more details.');
      }
    });
  }

  function runEncryptionInfo() {
    // Clear any previous status output
    clearStatusSilently();
    
    // Validate encryption key input using shared component
    const validationError = validateEncryptionKeyInput('encinfo');
    if (validationError) {
      setStatus('Error: ' + validationError);
      return;
    }

    const detailLevel = document.getElementById('detailLevel').value;
    const keyType = document.getElementById('keyType_encinfo').value;

    // Auto-scroll to Status section to show operation progress
    showTab('status');
    showStatusLoading('Analyzing LUKS encryption...');
    updateStatus('Starting encryption analysis...\nAnalyzing LUKS encrypted drives and slot configurations, please wait...');

    // Prepare data using the same pattern as Auto Start (which works)
    const postData = {
      keyType: keyType,
      detailLevel: detailLevel
    };
    
    if (keyType === 'passphrase') {
      const passphrase = document.getElementById('passphrase_encinfo').value;
      postData.passphrase = passphrase;
      
      // Add CSRF token with debug output
      console.log('DEBUG: CSRF token available:', csrf_token);
      console.log('DEBUG: CSRF token length:', csrf_token ? csrf_token.length : 'undefined');
      console.log('DEBUG: CSRF token type:', typeof csrf_token);
      if (csrf_token && csrf_token.length > 0) {
        postData.csrf_token = csrf_token;
        console.log('DEBUG: CSRF token added to postData');
      } else {
        console.log('WARNING: CSRF token is empty or undefined!');
      }
      
      // Make request directly for passphrase
      makeEncryptionInfoAjaxRequest(postData);
    } else {
      const keyfileInput = document.getElementById('keyfile_encinfo');
      if (keyfileInput.files && keyfileInput.files[0]) {
        // Convert file to base64 (same pattern as Auto Start)
        const reader = new FileReader();
        reader.onload = function(e) {
          const base64Data = e.target.result;
          postData.keyfileData = base64Data;
          
          // Add CSRF token with debug output
          console.log('DEBUG: CSRF token available (keyfile):', csrf_token);
          console.log('DEBUG: CSRF token length (keyfile):', csrf_token ? csrf_token.length : 'undefined');
          if (csrf_token && csrf_token.length > 0) {
            postData.csrf_token = csrf_token;
            console.log('DEBUG: CSRF token added to postData (keyfile)');
          } else {
            console.log('WARNING: CSRF token is empty or undefined (keyfile)!');
          }
          
          makeEncryptionInfoAjaxRequest(postData);
        };
        reader.readAsDataURL(keyfileInput.files[0]);
        return;
      } else {
        setStatus('Error: No keyfile selected');
        return;
      }
    }
  }
  
  function makeEncryptionInfoAjaxRequest(postData) {
    console.log('DEBUG: About to send AJAX request with data:', postData);
    console.log('DEBUG: Data keys:', Object.keys(postData));
    console.log('DEBUG: CSRF token in postData:', postData.csrf_token);
    
    // Try the exact same AJAX pattern as the working Auto Start function
    $.ajax({
      url: '/plugins/luks-key-management/scripts/run_encryption_info.php',
      type: 'POST',
      data: postData,
      beforeSend: function(xhr) {
        console.log('DEBUG: AJAX request starting with data keys:', Object.keys(postData));
        console.log('DEBUG: AJAX CSRF token being sent:', postData.csrf_token);
      },
      success: function(data) {
        setStatus(data);
      },
      error: function() {
        setStatus('Error: Failed to execute encryption analysis. Check browser console for more details.');
      }
    });
  }

  function downloadEncryptionInfo() {
    // Clear any previous status output
    clearStatusSilently();
    
    // Validate encryption key input using shared component
    const validationError = validateEncryptionKeyInput('encinfo');
    if (validationError) {
      setStatus('Error: ' + validationError);
      return;
    }

    const detailLevel = document.getElementById('detailLevel').value;
    const keyType = document.getElementById('keyType_encinfo').value;

    // Auto-scroll to Status section to show operation progress
    showTab('status');
    showStatusLoading('Preparing encryption analysis download...');
    updateStatus('Preparing encryption analysis for download...\nGenerating encrypted analysis file, please wait...');

    // Prepare data using the same pattern as Auto Start (which works)
    const postData = {
      keyType: keyType,
      detailLevel: detailLevel
    };
    
    if (keyType === 'passphrase') {
      const passphrase = document.getElementById('passphrase_encinfo').value;
      postData.passphrase = passphrase;
      
      // Add CSRF token
      if (csrf_token) {
        postData.csrf_token = csrf_token;
      }
      
      // Make request directly for passphrase
      makeEncryptionDownloadAjaxRequest(postData);
    } else {
      const keyfileInput = document.getElementById('keyfile_encinfo');
      if (keyfileInput.files && keyfileInput.files[0]) {
        // Convert file to base64 (same pattern as Auto Start)
        const reader = new FileReader();
        reader.onload = function(e) {
          const base64Data = e.target.result;
          postData.keyfileData = base64Data;
          
          // Add CSRF token
          if (csrf_token) {
            postData.csrf_token = csrf_token;
          }
          
          makeEncryptionDownloadAjaxRequest(postData);
        };
        reader.readAsDataURL(keyfileInput.files[0]);
        return;
      } else {
        setStatus('Error: No keyfile selected');
        return;
      }
    }
  }
  
  function makeEncryptionDownloadAjaxRequest(postData) {
    $.ajax({
      url: '/plugins/luks-key-management/scripts/run_encryption_download.php',
      type: 'POST',
      data: postData,
      success: function(data) {
        setStatus(data);
        
        // Check if we need to download the analysis file
        const downloadMatch = data.match(/DOWNLOAD_READY: (.+)/);
        if (downloadMatch) {
          const downloadPath = downloadMatch[1];
          const filename = downloadPath.split('/').pop();
          downloadAnalysisFile(filename);
        }
      },
      error: function() {
        setStatus('Error: Failed to generate encryption analysis download. Check browser console for more details.');
      }
    });
  }

  function downloadAnalysisFile(filename) {
    // Create direct download link - file is accessible via plugin downloads directory
    const downloadUrl = '/plugins/luks-key-management/downloads/' + filename;
    
    // Create a temporary anchor element to trigger download
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = filename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Update status to inform user
    updateStatus('\nEncryption analysis download initiated. Check your browser\'s download folder.');
    
    // Clean up the temporary file after a delay
    setTimeout(function() {
      fetch('/plugins/luks-key-management/scripts/cleanup_download.php', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'filename=' + encodeURIComponent(filename)
      });
    }, 5000); // 5 second delay to ensure download completes
  }

  function goToDiskSettings() {
    // Get current protocol, hostname, and port from the current page
    const currentUrl = window.location;
    const baseUrl = `${currentUrl.protocol}//${currentUrl.host}`;
    const mainTabUrl = `${baseUrl}/Main`;
    
    // Open Main tab in a new tab
    const newWindow = window.open(mainTabUrl, '_blank');
    
    // Wait for page to load, then scroll to bottom (where Array Operation section is)
    if (newWindow) {
      const checkForLoad = setInterval(function() {
        try {
          if (newWindow.document.readyState === 'complete') {
            clearInterval(checkForLoad);
            
            // Small delay to ensure content is fully rendered
            setTimeout(function() {
              try {
                // Scroll to the bottom of the page where Array Operation section is located
                const scrollHeight = Math.max(
                  newWindow.document.body.scrollHeight,
                  newWindow.document.documentElement.scrollHeight
                );
                
                newWindow.scrollTo({
                  top: scrollHeight,
                  behavior: 'smooth'
                });
              } catch (e) {
                // Fallback for cross-origin restrictions
                try {
                  newWindow.scrollTo(0, 999999); // Large number to ensure bottom
                } catch (scrollError) {
                  // Browser restrictions prevent scrolling - user will need to scroll manually
                }
              }
            }, 500); // 500ms delay to ensure DOM is fully rendered
          }
        } catch (e) {
          // Ignore cross-origin errors during loading
        }
      }, 100);
      
      // Clean up interval after 10 seconds to avoid memory leaks
      setTimeout(function() {
        clearInterval(checkForLoad);
      }, 10000);
    }
  }

  // Shared encryption key input component functions
  function toggleKeyInput(tabname) {
    const keyType = document.getElementById('keyType_' + tabname).value;
    const passphraseSection = document.getElementById('passphraseSection_' + tabname);
    const keyfileSection = document.getElementById('keyfileSection_' + tabname);
    
    if (keyType === 'passphrase') {
      passphraseSection.style.display = 'block';
      keyfileSection.style.display = 'none';
      // Clear keyfile input when switching to passphrase
      const keyfileInput = document.getElementById('keyfile_' + tabname);
      if (keyfileInput) keyfileInput.value = '';
    } else {
      passphraseSection.style.display = 'none'; 
      keyfileSection.style.display = 'block';
      // Clear passphrase input when switching to keyfile
      const passphraseInput = document.getElementById('passphrase_' + tabname);
      if (passphraseInput) passphraseInput.value = '';
    }
  }

  function togglePasswordVisibility(tabname) {
    const passphraseInput = document.getElementById('passphrase_' + tabname);
    const checkbox = event.target;
    
    if (checkbox.checked) {
      passphraseInput.type = 'text';
    } else {
      passphraseInput.type = 'password';
    }
  }

  function validateKeyfileSize(fileInput, tabname) {
    const maxSize = 8 * 1024 * 1024; // 8 MiB
    const file = fileInput.files[0];
    
    if (file && file.size > maxSize) {
      alert('Keyfile exceeds 8 MiB limit (Unraid standard). Please select a smaller file.');
      fileInput.value = ''; // Clear the input
      return false;
    }
    return true;
  }

  function validateEncryptionKeyInput(tabname) {
    const keyType = document.getElementById('keyType_' + tabname).value;
    
    if (keyType === 'passphrase') {
      const passphrase = document.getElementById('passphrase_' + tabname).value;
      if (!passphrase) {
        return 'Please enter your encryption passphrase.';
      }
      if (passphrase.length > 512) {
        return 'Passphrase exceeds 512 character limit (Unraid standard).';
      }
    } else {
      const keyfileInput = document.getElementById('keyfile_' + tabname);
      if (!keyfileInput.files || !keyfileInput.files[0]) {
        return 'Please select your encryption keyfile.';
      }
      
      // Validate ZIP password for keyfile users (only for autostart and headers tabs)
      if (tabname === 'autostart' || tabname === 'headers') {
        const zipPassword = document.getElementById('zipPassword_' + tabname).value;
        if (!zipPassword) {
          return 'Please enter a password to encrypt the backup ZIP file.';
        }
        if (zipPassword.length < 4) {
          return 'ZIP password must be at least 4 characters long.';
        }
        if (zipPassword.length > 512) {
          return 'ZIP password exceeds 512 character limit.';
        }
      }
    }
    return null; // Valid
  }

  // Shared download detection function - checks output for DOWNLOAD_READY and triggers download
  function handleDownloadDetection(data, backupLocation, dryRun, context = 'default') {
    console.log('DEBUG: Checking download - backupLocation:', backupLocation, 'dryRun:', dryRun, 'context:', context);
    if (backupLocation === 'download' && dryRun === 'no') {
      // Look for download ready indicator in the output
      console.log('DEBUG: Looking for DOWNLOAD_READY in output...');
      const downloadMatch = data.match(/DOWNLOAD_READY: (\/usr\/local\/emhttp\/plugins\/luks-key-management\/downloads\/[^D\s]+\.zip)/);
      console.log('DEBUG: Download match result:', downloadMatch);
      if (downloadMatch) {
        const downloadPath = downloadMatch[1].trim();
        const filename = downloadPath.split('/').pop();
        console.log('DEBUG: Starting download for file:', filename);
        console.log('DEBUG: Full download path:', downloadPath);
        console.log('DEBUG: Raw matched string:', downloadMatch[1]);
        downloadBackupFile(filename, context);
      } else {
        console.log('DEBUG: No DOWNLOAD_READY found in output');
      }
    } else {
      console.log('DEBUG: Download not triggered - conditions not met');
    }
  }

  // Function to toggle ZIP password visibility
  function togglePasswordVisibility(tabname) {
    const passwordInput = document.getElementById('zipPassword_' + tabname);
    const checkbox = document.getElementById('showZipPassword_' + tabname);
    
    if (checkbox.checked) {
      passwordInput.type = 'text';
    } else {
      passwordInput.type = 'password';
    }
  }

  // Update backup location description for auto-start tab
  function updateBackupLocationDescription() {
    const location = document.getElementById('backupLocation').value;
    const desc = document.getElementById('backupLocationDescription');
    
    if (location === 'download') {
      desc.textContent = 'LUKS headers will always be backed up for safety. Files will be downloaded to your browser\'s download folder.';
    } else {
      desc.textContent = 'LUKS headers will always be backed up for safety. Files will be saved to /boot/config/luksheaders/ on your Unraid boot device.';
    }
  }

  // Update backup location description for LUKS headers tab
  function updateHeadersBackupLocationDescription() {
    const location = document.getElementById('headersBackupLocation').value;
    const desc = document.getElementById('headersBackupLocationDescription');
    
    if (location === 'download') {
      desc.textContent = 'Files will be downloaded to your browser\'s download folder.';
    } else {
      desc.textContent = 'Files will be saved to /boot/config/luksheaders/ on your Unraid boot device.';
    }
  }

  // Smart state detection functions for new interface
  function loadSmartStatus() {
    console.log('DEBUG: Loading smart status...');
    
    // Show loading indicator
    document.getElementById('smartStatusLoading').style.display = 'block';
    hideAllStateCards();
    
    fetch('/plugins/luks-key-management/scripts/get_smart_status.php', {
      method: 'GET',
      credentials: 'same-origin'
    })
    .then(response => {
      console.log('DEBUG: Smart status HTTP response status:', response.status);
      console.log('DEBUG: Smart status response headers:', response.headers);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response.text(); // Get as text first to see raw response
    })
    .then(text => {
      console.log('DEBUG: Smart status raw response text:', text);
      
      try {
        const data = JSON.parse(text);
        console.log('DEBUG: Smart status parsed JSON:', data);
        displaySmartState(data);
      } catch (parseError) {
        console.error('DEBUG: JSON parse error:', parseError);
        throw new Error(`Invalid JSON response: ${text.substring(0, 200)}...`);
      }
    })
    .catch(error => {
      console.error('DEBUG: Smart status error:', error);
      // Hide loading indicator and show manual refresh option
      document.getElementById('smartStatusLoading').style.display = 'none';
      document.getElementById('manualRefreshOption').style.display = 'block';
      hideAllStateCards();
    });
  }
  
  function displaySmartState(statusData) {
    // Hide loading indicator
    document.getElementById('smartStatusLoading').style.display = 'none';
    hideAllStateCards();
    
    const systemState = statusData.system_state || 'unknown';
    const autoUnlockEnabled = statusData.auto_unlock_enabled || false;
    const unlockableDevices = statusData.unlockable_devices || 'none';
    
    // Extract just the device count from the unlockableDevices string
    // Format is typically: "2 device(s): md1p1, md2p1" - we want just "2 device(s)"
    const deviceCountOnly = unlockableDevices.includes(':') ? 
      unlockableDevices.split(':')[0].trim() : unlockableDevices;
    
    console.log('DEBUG: Smart status data received:', statusData);
    console.log('DEBUG: System state:', systemState, 'Auto-unlock enabled:', autoUnlockEnabled);
    console.log('DEBUG: Keys exist:', statusData.keys_exist, 'Keys work:', statusData.keys_work);
    console.log('DEBUG: Device count only:', deviceCountOnly);
    console.log('DEBUG: Debug info:', statusData.debug);
    
    switch (systemState) {
      case 'array_stopped':
        document.getElementById('stateArrayStopped').style.display = 'block';
        break;
        
      case 'setup_required':
        document.getElementById('stateSetupRequired').style.display = 'block';
        break;
        
      case 'no_encrypted_disks':
        document.getElementById('stateNoEncryptedDisks').style.display = 'block';
        break;
        
      case 'ready_disabled':
        document.getElementById('stateReadyDisabled').style.display = 'block';
        document.getElementById('unlockableDevicesDisabled').textContent = deviceCountOnly;
        break;
        
      case 'ready_enabled':
        document.getElementById('stateReadyEnabled').style.display = 'block';
        document.getElementById('unlockableDevicesEnabled').textContent = deviceCountOnly;
        break;
        
      default:
        // Show error state
        document.getElementById('smartStatusLoading').style.display = 'block';
        document.getElementById('smartStatusLoading').innerHTML = 
          '<strong style="color: #ff6b6b;">Unknown system state: ' + systemState + '. Please refresh the page.</strong>';
    }
  }
  
  function hideAllStateCards() {
    document.getElementById('stateArrayStopped').style.display = 'none';
    document.getElementById('stateSetupRequired').style.display = 'none';
    document.getElementById('stateNoEncryptedDisks').style.display = 'none';
    document.getElementById('stateReadyDisabled').style.display = 'none';
    document.getElementById('stateReadyEnabled').style.display = 'none';
    document.getElementById('manualRefreshOption').style.display = 'none';
  }
  
  
  function toggleAutoUnlock(enable) {
    console.log('DEBUG: toggleAutoUnlock called with enable:', enable);
    
    // Show loading message in current card instead of status tab
    showInCardMessage(enable ? 'Enabling auto-unlock...' : 'Disabling auto-unlock...', 0);
    
    const action = enable ? 'enable' : 'disable';
    const postData = { action: action };
    
    if (csrf_token) {
      postData.csrf_token = csrf_token;
    }
    
    fetch('/plugins/luks-key-management/scripts/run_event_script.php', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams(postData).toString()
    })
    .then(response => response.text())
    .then(data => {
      console.log('DEBUG: Toggle response:', data);
      
      // Check for success/failure in response
      if (data.includes('successfully')) {
        // Show brief success message in card
        showInCardMessage(enable ? 'Auto-unlock enabled successfully! Transitioning...' : 'Auto-unlock disabled successfully! Transitioning...', 2000);
        
        // Refresh smart status to update state cards (orange ↔ green) after brief delay
        setTimeout(() => {
          loadSmartStatus();
        }, 1500);
      } else {
        // Show error in card
        showInCardMessage('Operation failed. Check Status tab for details.', 5000);
        // For errors, also show in status tab for debugging
        showTab('status');
        setStatus('Error: ' + data);
      }
    })
    .catch(error => {
      console.error('DEBUG: Toggle error:', error);
      showInCardMessage('Network error occurred. Check Status tab for details.', 5000);
      // Also show in status tab for debugging
      showTab('status');
      setStatus('Error: Failed to toggle auto-unlock - ' + error.message);
      // Reload status to get current state
      loadSmartStatus();
    });
  }
  
  function showSetupForm() {
    console.log('DEBUG: showSetupForm called');
    
    // Hide all state cards
    hideAllStateCards();
    
    // Show the setup form
    document.getElementById('setupForm').style.display = 'block';
    
    // Clear any previous form data
    document.getElementById('passphrase_autostart').value = '';
    document.getElementById('keyfile_autostart').value = '';
    document.getElementById('zipPassword_autostart').value = '';
    
    // Reset to passphrase mode
    document.getElementById('keyType_autostart').value = 'passphrase';
    toggleKeyInput('autostart');
    
    // Add cancel button functionality
    addCancelButton();
  }
  
  function addCancelButton() {
    // Check if cancel button already exists
    if (document.getElementById('cancelSetupButton')) {
      return;
    }
    
    // Find the submit button container and add cancel button
    const submitContainer = document.querySelector('#setupForm dl:last-of-type dd');
    if (submitContainer) {
      const cancelButton = document.createElement('button');
      cancelButton.type = 'button';
      cancelButton.id = 'cancelSetupButton';
      cancelButton.textContent = 'Cancel';
      cancelButton.style.marginLeft = '10px';
      cancelButton.onclick = function() {
        hideSetupForm();
        loadSmartStatus(); // Reload the smart status
      };
      
      submitContainer.appendChild(cancelButton);
    }
  }
  
  function hideSetupForm() {
    console.log('DEBUG: hideSetupForm called');
    
    // Hide the setup form
    document.getElementById('setupForm').style.display = 'none';
    
    // Remove cancel button if it exists
    const cancelButton = document.getElementById('cancelSetupButton');
    if (cancelButton) {
      cancelButton.remove();
    }
  }

  // Manual test functions for debugging (can be called from browser console)
  window.testSmartDetection = function() {
    console.log('=== Manual Smart Detection Test ===');
    loadSmartStatus();
  };
  
  window.testDetectionFunction = function(functionName) {
    console.log('=== Manual Detection Function Test: ' + functionName + ' ===');
    
    fetch('/plugins/luks-key-management/scripts/run_event_script.php', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: 'action=' + encodeURIComponent(functionName) + (csrf_token ? '&csrf_token=' + encodeURIComponent(csrf_token) : '')
    })
    .then(response => response.text())
    .then(data => {
      console.log('Response for ' + functionName + ':', data);
    })
    .catch(error => {
      console.error('Error testing ' + functionName + ':', error);
    });
  };
  
  window.testAllDetectionFunctions = function() {
    console.log('=== Testing All Detection Functions ===');
    const functions = ['check_keys_exist', 'test_keys_work', 'unlockable_devices', 'system_state'];
    functions.forEach(func => {
      setTimeout(() => testDetectionFunction(func), 500);
    });
  };

  // Initialize descriptions and status on page load
  document.addEventListener('DOMContentLoaded', function() {
    updateBackupLocationDescription();
    updateHeadersBackupLocationDescription();
    
    // Initialize smart status detection
    loadSmartStatus();
  });

</script>