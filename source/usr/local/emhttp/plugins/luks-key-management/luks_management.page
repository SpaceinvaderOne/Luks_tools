Menu="Utilities"
Title="Multi-Function LUKS Key Utility"
Icon="key"
---
<?
# Get CSRF token from Unraid's variable system
$csrf_token = $var['csrf_token'] ?? '';

# Get plugin version
$version_file = '/boot/config/plugins/luks-key-management/VERSION';
$version = file_exists($version_file) ? trim(file_get_contents($version_file)) : 'Unknown';
?>

<div style="color: #F15A2C; font-weight: bold; font-size: 16px; margin-bottom: 10px;">
Plugin Version: <?=$version?>
</div>

<div style="margin-bottom: 20px; color: var(--text-color);">
This plugin manages encrypted drives with tools for auto-unlock at boot, LUKS header backup, key changes, and viewing encryption slots and metadata. Choose which tool to use from the tabs below.
</div>

<style>
/* CSS Variables for Light/Dark Mode Support */
:root {
  --note-bg: #f5f5f5;
  --important-bg: #e8f4f8;
  --text-color: #000000;
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
  :root {
    --note-bg: #2a2a2a;
    --important-bg: #1e3a4a;
    --text-color: #ffffff;
  }
}

/* Unraid dark mode class support */
.theme-dark {
  --note-bg: #2a2a2a;
  --important-bg: #1e3a4a;
  --text-color: #ffffff;
}

/* Status output container */
#statusOutput {
  background-color: #1a1a1a;
  color: #fff;
  padding: 15px;
  border-radius: 5px;
  min-height: 400px;
  max-height: 600px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
  font-family: 'Courier New', monospace;
  font-size: 12px;
  border: 1px solid #444;
}

/* Loading spinner styles */
.status-loading {
  text-align: center;
  padding: 15px;
  background: #2a2a2a;
  border-radius: 5px;
  margin: 10px 0;
  border: 1px solid #444;
}

.status-loading .spinner {
  margin: 0 auto 10px auto;
  width: 120px;
  height: 70px;
}

.status-loading .loading-message {
  color: #fff;
  font-size: 16px;
}

.description {
  font-size: 13px;
  opacity: 0.7;
  margin: 5px 0 0 0;
  line-height: 1.5;
  max-width: 600px;
}

/* Tab navigation - Custom orange styling */
.tab-nav {
  margin: 20px 0;
}

.tab-nav ul {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

.tab-nav li {
  margin: 0;
}

.tab-nav button {
  display: block;
  padding: 10px 20px;
  background: transparent;
  border: 2px solid #F15A2C;
  color: var(--text-color, #000);
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  text-decoration: none;
  border-radius: 6px;
  width: 270px;
  text-align: center;
  transition: all 0.2s ease;
  margin-bottom: 8px;
}

.tab-nav button:hover {
  background: rgba(241, 90, 44, 0.1);
  color: #F15A2C;
}

.tab-nav button.active {
  background: #F15A2C;
  border: 2px solid #F15A2C;
  color: #ffffff;
  font-weight: bold;
}

.tab-nav i {
  margin-right: 8px;
}

/* Tab content */
.tab-content {
  display: none;
  margin: 20px 0;
}

.tab-content.active {
  display: block;
}

.tab-content h2 {
  margin-top: 0;
  padding-top: 0;
  border-top: none;
  color: #F15A2C;
}

/* Standard button styling for consistency */
.tab-content button,
.tab-content input[type="submit"] {
  padding: 8px 16px;
  margin: 2px;
  min-width: 120px;
  font-size: 14px;
}

.tab-content button + button {
  margin-left: 8px;
}

</style>

<div class="tab-nav">
  <ul>
    <li><button onclick="showTab('auto-start')" id="tab-auto-start" class="active"><i class="fa fa-play"></i>Auto Start</button></li>
    <li><button onclick="showTab('luks-headers')" id="tab-luks-headers"><i class="fa fa-shield"></i>LUKS Headers</button></li>
    <li><button onclick="showTab('go-file')" id="tab-go-file"><i class="fa fa-file-code-o"></i>Go File</button></li>
    <li><button onclick="showTab('encryption-info')" id="tab-encryption-info"><i class="fa fa-info"></i>Encryption Info</button></li>
    <li><button onclick="showTab('change-key')" id="tab-change-key"><i class="fa fa-key"></i>Change Encryption Key</button></li>
    <li><button onclick="showTab('status')" id="tab-status"><i class="fa fa-terminal"></i>Status</button></li>
  </ul>
</div>

<div id="content-auto-start" class="tab-content active">
  <h2><i class="fa fa-play"></i> Auto Start</h2>
  
  <p>This tool provides complete auto-unlock setup in one action. It will backup your LUKS headers, refresh the hardware-derived key, and automatically enable auto-unlock at boot. Manual unlock is always possible using your original passphrase. Auto-unlock only works when the server runs on the original hardware and router.</p>
  
  <p><strong>Backup Security:</strong> When using passphrase authentication, header backups are encrypted with your LUKS passphrase. When using keyfile authentication, you can provide a custom password to encrypt the backup ZIP file for security.</p>
  
  <form id="autostartForm">
    <h3>Complete Auto-Unlock Setup</h3>
    
    <dl>
      <dt>Existing Encryption Key</dt>
      <dd>
        <select id="keyType_autostart" class="short" onchange="toggleKeyInput('autostart')">
          <option value="passphrase" selected>Passphrase</option>
          <option value="keyfile">Keyfile</option>
        </select>
      </dd>
    </dl>
    
    <div id="passphraseSection_autostart">
      <dl>
        <dt>Enter Existing Passphrase</dt>
        <dd>
          <input type="password" id="passphrase_autostart" name="passphrase" class="short" maxlength="512" required>
          <label><input type="checkbox" onchange="togglePasswordVisibility('autostart')"> show passphrase</label>
          <div class="description">Enter your original LUKS encryption passphrase.</div>
        </dd>
      </dl>
    </div>
    
    <div id="keyfileSection_autostart" style="display: none;">
      <dl>
        <dt>Select Existing Keyfile</dt>
        <dd>
          <input type="file" id="keyfile_autostart" name="keyfile" onchange="validateKeyfileSize(this, 'autostart')">
          <div class="description">Select your original LUKS encryption keyfile. Maximum size: 8 MiB. Any file type accepted.</div>
        </dd>
      </dl>
      
      <dl>
        <dt>Backup ZIP Password</dt>
        <dd>
          <input type="password" id="zipPassword_autostart" class="short" maxlength="512">
          <label style="margin-left: 10px;"><input type="checkbox" id="showZipPassword_autostart" onchange="togglePasswordVisibility('autostart')"> Show password</label>
          <div class="description">Password to encrypt the LUKS headers backup ZIP file. Required for keyfile authentication.</div>
        </dd>
      </dl>
    </div>
    
    <dl>
      <dt>Header Backup Location</dt>
      <dd>
        <select id="backupLocation" name="backupLocation" class="short">
          <option value="download" selected>Download to PC</option>
          <option value="yes">Save to server</option>
        </select>
        <div class="description">LUKS headers will always be backed up for safety. Choose where to save the encrypted backup.</div>
      </dd>
    </dl>
    
    <dl>
      <dt>Dry Run</dt>
      <dd>
        <select id="dryRun" name="dryRun" class="short">
          <option value="yes" selected>Yes</option>
          <option value="no">No</option>
        </select>
        <div class="description">Simulates the process without making changes. Select 'No' to apply changes.</div>
      </dd>
    </dl>
    
    
    <dl>
      <dt>&nbsp;</dt>
      <dd>
        <span><input type="submit" value="ENABLE AUTO-UNLOCK" onclick="runAutoStartSetup(); return false;"></span>
      </dd>
    </dl>
  </form>
</div>

<div id="content-luks-headers" class="tab-content">
  <h2><i class="fa fa-shield"></i> LUKS Headers</h2>
  
  <p>Create backups of your LUKS headers for all devices that your authentication method can unlock. These backups are essential for recovery if headers become corrupted.</p>
  
  <p><strong>Backup Security:</strong> When using passphrase authentication, header backups are encrypted with your LUKS passphrase. When using keyfile authentication, you can provide a custom password to encrypt the backup ZIP file for security.</p>
  
  <form id="headersForm">
    <h3>Backup LUKS Headers</h3>
    
    <dl>
      <dt>Existing Encryption Key</dt>
      <dd>
        <select id="keyType_headers" class="short" onchange="toggleKeyInput('headers')">
          <option value="passphrase" selected>Passphrase</option>
          <option value="keyfile">Keyfile</option>
        </select>
      </dd>
    </dl>
    
    <div id="passphraseSection_headers">
      <dl>
        <dt>Enter Existing Passphrase</dt>
        <dd>
          <input type="password" id="passphrase_headers" name="passphrase" class="short" maxlength="512" required>
          <label><input type="checkbox" onchange="togglePasswordVisibility('headers')"> show passphrase</label>
          <div class="description">Enter your LUKS encryption key. All devices this passphrase unlocks will be backed up.</div>
        </dd>
      </dl>
    </div>
    
    <div id="keyfileSection_headers" style="display: none;">
      <dl>
        <dt>Select Existing Keyfile</dt>
        <dd>
          <input type="file" id="keyfile_headers" name="keyfile" onchange="validateKeyfileSize(this, 'headers')">
          <div class="description">Select your LUKS encryption keyfile. All devices this keyfile unlocks will be backed up. Maximum size: 8 MiB. Any file type accepted.</div>
        </dd>
      </dl>
      
      <dl>
        <dt>Backup ZIP Password</dt>
        <dd>
          <input type="password" id="zipPassword_headers" class="short" maxlength="512">
          <label style="margin-left: 10px;"><input type="checkbox" id="showZipPassword_headers" onchange="togglePasswordVisibility('headers')"> Show password</label>
          <div class="description">Password to encrypt the LUKS headers backup ZIP file. Required for keyfile authentication.</div>
        </dd>
      </dl>
    </div>
    
    <dl>
      <dt>Header Backup Location</dt>
      <dd>
        <select id="headersBackupLocation" name="headersBackupLocation" class="short">
          <option value="yes">Save to server</option>
          <option value="download" selected>Download to PC</option>
        </select>
        <div class="description">Choose to save the encrypted backup on the server or download it to your computer.</div>
      </dd>
    </dl>
    
    <dl>
      <dt>&nbsp;</dt>
      <dd>
        <span><button type="button" onclick="runHeadersBackup()">Backup Headers</button></span>
      </dd>
    </dl>
  </form>
</div>

<div id="content-go-file" class="tab-content">
  <h2><i class="fa fa-file-code-o"></i> Go File</h2>
  
  <p>Control auto-unlock functionality by managing the startup configuration in your go file. This allows you to enable or disable auto-unlock without affecting your LUKS keys.</p>
  
  <form id="gofileForm">
    <h3>Boot Auto-Unlock Control</h3>
    
    <dl>
      <dt>Action</dt>
      <dd>
        <select id="goAction" name="goAction" class="short">
          <option value="add" selected>Enable auto-unlock at boot</option>
          <option value="remove">Disable auto-unlock at boot</option>
        </select>
        <div class="description">Choose whether to enable or disable automatic LUKS unlocking during system startup.</div>
      </dd>
    </dl>
    
    <dl>
      <dt>&nbsp;</dt>
      <dd>
        <span><button type="button" onclick="runGoCommand()">Update Boot Configuration</button></span>
      </dd>
    </dl>
  </form>
  
  <div style="margin-top: 15px; padding: 10px; background: var(--note-bg, #f5f5f5); color: var(--text-color, #000000); border-radius: 5px; border-left: 4px solid #FF9800;">
    <strong>Note:</strong> This only controls whether auto-unlock runs at boot. It does not affect your LUKS keys or hardware key configuration. Use this to temporarily disable auto-unlock or re-enable it after maintenance.
  </div>
</div>

<div id="content-encryption-info" class="tab-content">
  <h2><i class="fa fa-info"></i> Encryption Info</h2>
  
  <p>View detailed information about LUKS encryption on your server. This provides insight into encrypted drives, slot usage, and key configurations.</p>
  
  <form id="encinfoForm">
    <h3>Encryption Analysis</h3>
    
    <dl>
      <dt>Existing Encryption Key</dt>
      <dd>
        <select id="keyType_encinfo" class="short" onchange="toggleKeyInput('encinfo')">
          <option value="passphrase" selected>Passphrase</option>
          <option value="keyfile">Keyfile</option>
        </select>
      </dd>
    </dl>
    
    <div id="passphraseSection_encinfo">
      <dl>
        <dt>Enter Existing Passphrase</dt>
        <dd>
          <input type="password" id="passphrase_encinfo" name="passphrase" class="short" maxlength="512" required>
          <label><input type="checkbox" onchange="togglePasswordVisibility('encinfo')"> show passphrase</label>
          <div class="description">Enter your LUKS encryption key to analyze encrypted drives and slots.</div>
        </dd>
      </dl>
    </div>
    
    <div id="keyfileSection_encinfo" style="display: none;">
      <dl>
        <dt>Select Existing Keyfile</dt>
        <dd>
          <input type="file" id="keyfile_encinfo" name="keyfile" onchange="validateKeyfileSize(this, 'encinfo')">
          <div class="description">Select your LUKS encryption keyfile to analyze encrypted drives and slots. Maximum size: 8 MiB. Any file type accepted.</div>
        </dd>
      </dl>
    </div>
    
    <dl>
      <dt>Detail Level</dt>
      <dd>
        <select id="detailLevel" name="detailLevel" class="short">
          <option value="simple" selected>Simple (drive list only)</option>
          <option value="detailed">Detailed (smart grouping with slots and metadata)</option>
          <option value="very_detailed">Very Detailed (individual device analysis)</option>
        </select>
        <div class="description">Choose how much information to display about your encrypted drives.</div>
      </dd>
    </dl>
    
    <dl>
      <dt>&nbsp;</dt>
      <dd>
        <span>
          <button type="button" onclick="runEncryptionInfo()">View Encryption Status</button>
          <button type="button" onclick="downloadEncryptionInfo()">Download Analysis</button>
        </span>
      </dd>
    </dl>
  </form>
  
  <div style="margin-top: 15px; padding: 10px; background: var(--note-bg, #f5f5f5); color: var(--text-color, #000000); border-radius: 5px; border-left: 4px solid #FF9800;">
    <strong>Security Note:</strong> Your passphrase is required to access LUKS metadata. This is read-only analysis and makes no changes to your encryption configuration.
  </div>
</div>

<div id="content-change-key" class="tab-content">
  <h2><i class="fa fa-key"></i> Change Encryption Key</h2>
  
  <h3>Change Primary Encryption Key</h3>
  
  <p>To modify your primary LUKS encryption authentication method, use Unraid's built-in disk management interface. This is the recommended and safest method for changing your encryption key or switching between passphrases and keyfiles.</p>
  
  <div style="background: var(--important-bg, #e8f4f8); color: var(--text-color, #000000); border: 1px solid #FF9800; padding: 15px; margin: 15px 0; border-radius: 5px;">
    <strong>Important:</strong> This process changes your <em>primary encryption authentication method</em> (passphrase or keyfile). 
    Your hardware-derived auto-unlock key (managed by this plugin) operates independently in a separate slot and will continue to function normally regardless of changes to your primary encryption method.
  </div>
  
  <h4>Instructions:</h4>
  <ol>
    <li>Click the button below to open Unraid's Disk Settings page and automatically scroll to the Encryption section</li>
    <li>Find your encrypted array or pool devices and click the "Change" button next to the device you want to modify</li>
    <li>In the "Change encryption key" dialog that opens:
      <ul>
        <li>Select your current encryption method in "Existing encryption key" (Passphrase or Keyfile)</li>
        <li>Enter your current passphrase OR select your current keyfile</li>
        <li>Choose your desired new encryption method in "Change encryption key" (Passphrase or Keyfile)</li>
        <li><em>Note: You can switch between methods - change from passphrase to keyfile or vice versa</em></li>
        <li>Enter your new passphrase OR select your new keyfile</li>
        <li>Complete any additional fields as required (retype passphrase if applicable)</li>
      </ul>
    </li>
    <li>Click "APPLY" to save the changes, then "DONE" to close the dialog</li>
  </ol>
  
  <div style="margin-top: 15px; padding: 10px; background: var(--note-bg, #f5f5f5); color: var(--text-color, #000000); border-radius: 5px; border-left: 4px solid #FF9800;">
    <strong>Troubleshooting:</strong> If the "Existing encryption key" dropdown is greyed out and cannot be changed, go to the Main tab in Unraid and click "Delete keyfile" under Array Operations (this only removes the stored keyfile reference, not your LUKS encryption key).
  </div>
  
  <dl>
    <dt>&nbsp;</dt>
    <dd>
      <span><button type="button" onclick="goToDiskSettings()">Go to Disk Settings → Encryption</button></span>
    </dd>
  </dl>
  
  <div style="margin-top: 15px; padding: 10px; background: var(--note-bg, #f5f5f5); color: var(--text-color, #000000); border-radius: 5px; border-left: 4px solid #FF9800;">
    <strong>Note:</strong> This feature uses Unraid's native encryption key management system. If the button doesn't work, manually navigate to Settings → Disk Settings in the main Unraid interface.
  </div>
</div>

<div id="content-status" class="tab-content">
  <h2><i class="fa fa-terminal"></i> Status</h2>
  
  <p>Operation output and status information will be displayed here. All plugin operations will automatically show their output in this section.</p>
  
  <h3>Current Operation Status</h3>
  
  <dl>
    <dt>&nbsp;</dt>
    <dd>
      <span><button type="button" onclick="clearStatus()">Clear Output</button></span>
    </dd>
  </dl>

<!-- Loading Spinner (hidden by default, positioned above status output) -->
<div id="status-loading" style="display: none; text-align: center; padding: 15px; background: #2a2a2a; border-radius: 5px; margin: 10px 0; border: 1px solid #444;">
  <div class="spinner" style="margin: 0 auto 10px auto; width: 120px; height: 70px;"></div>
  <div id="loading-message" style="color: #fff; font-size: 16px;">Processing request...</div>
</div>

<pre id="statusOutput">No operations performed yet. Output from all plugin operations will appear here.</pre>
</div>

<script>
  // TODO: Remove all console.log('DEBUG: ...') statements before final release
  
  // Make CSRF token available to JavaScript
  var csrf_token = '<?=$csrf_token?>';
  
  // Tab functionality
  function showTab(tabId) {
    console.log('DEBUG: Switching to tab:', tabId);
    
    // Hide all tab contents
    const allContents = document.querySelectorAll('.tab-content');
    allContents.forEach(content => {
      content.classList.remove('active');
    });
    
    // Remove active class from all tab buttons
    const allButtons = document.querySelectorAll('.tab-nav button');
    allButtons.forEach(button => {
      button.classList.remove('active');
    });
    
    // Show selected tab content
    const selectedContent = document.getElementById('content-' + tabId);
    if (selectedContent) {
      selectedContent.classList.add('active');
      console.log('DEBUG: Activated content for tab:', tabId);
    } else {
      console.error('DEBUG: Could not find content for tab:', tabId);
    }
    
    // Activate selected tab button
    const selectedButton = document.getElementById('tab-' + tabId);
    if (selectedButton) {
      selectedButton.classList.add('active');
      console.log('DEBUG: Activated button for tab:', tabId);
    } else {
      console.error('DEBUG: Could not find button for tab:', tabId);
    }
  }
  
  // Unified status output functions
  function updateStatus(message) {
    const statusOutput = document.getElementById('statusOutput');
    statusOutput.textContent += message + '\n';
    statusOutput.scrollTop = statusOutput.scrollHeight;
    
    // Auto-switch to status tab
    showTab('status');
  }

  function setStatus(message) {
    // Hide loading spinner when we get output
    hideStatusLoading();
    
    const statusOutput = document.getElementById('statusOutput');
    statusOutput.textContent = message + '\n';
    statusOutput.scrollTop = statusOutput.scrollHeight;
    
    // Auto-switch to status tab
    showTab('status');
  }

  function clearStatus() {
    hideStatusLoading();
    document.getElementById('statusOutput').textContent = 'Output cleared.\n';
  }

  // Loading spinner control functions
  function showStatusLoading(message) {
    console.log('DEBUG: showStatusLoading called with message:', message);
    const loadingDiv = document.getElementById('status-loading');
    const loadingMessage = document.getElementById('loading-message');
    const spinnerDiv = loadingDiv.querySelector('.spinner');
    
    console.log('DEBUG: loadingDiv found:', !!loadingDiv);
    console.log('DEBUG: loadingMessage found:', !!loadingMessage);
    console.log('DEBUG: spinnerDiv found:', !!spinnerDiv);
    
    if (loadingDiv && loadingMessage && spinnerDiv) {
      loadingMessage.textContent = message || 'Processing...';
      
      // Use the official Unraid spinner animation
      if (typeof unraid_logo !== 'undefined') {
        spinnerDiv.innerHTML = unraid_logo;
      } else {
        // Fallback: try to use the same method as the main Unraid interface
        spinnerDiv.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 133.52 76.97" class="unraid_mark"><defs><linearGradient id="unraid_logo_plugin" x1="23.76" y1="81.49" x2="109.76" y2="-4.51" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#e32929"/><stop offset="1" stop-color="#ff8d30"/></linearGradient></defs><path d="m70,19.24zm57,0l6.54,0l0,38.49l-6.54,0l0,-38.49z" fill="url(#unraid_logo_plugin)" class="unraid_mark_9"/><path d="m70,19.24zm47.65,11.9l-6.55,0l0,-23.79l6.55,0l0,23.79z" fill="url(#unraid_logo_plugin)" class="unraid_mark_8"/><path d="m70,19.24zm31.77,-4.54l-6.54,0l0,-14.7l6.54,0l0,14.7z" fill="url(#unraid_logo_plugin)" class="unraid_mark_7"/><path d="m70,19.24zm15.9,11.9l-6.54,0l0,-23.79l6.54,0l0,23.79z" fill="url(#unraid_logo_plugin)" class="unraid_mark_6"/><path d="m63.49,19.24l6.51,0l0,38.49l-6.51,0l0,-38.49z" fill="url(#unraid_logo_plugin)" class="unraid_mark_5"/><path d="m70,19.24zm-22.38,26.6l6.54,0l0,23.78l-6.54,0l0,-23.78z" fill="url(#unraid_logo_plugin)" class="unraid_mark_4"/><path d="m70,19.24zm-38.26,43.03l6.55,0l0,14.73l-6.55,0l0,-14.73z" fill="url(#unraid_logo_plugin)" class="unraid_mark_3"/><path d="m70,19.24zm-54.13,26.6l6.54,0l0,23.78l-6.54,0l0,-23.78z" fill="url(#unraid_logo_plugin)" class="unraid_mark_2"/><path d="m70,19.24zm-63.46,38.49l-6.54,0l0,-38.49l6.54,0l0,38.49z" fill="url(#unraid_logo_plugin)" class="unraid_mark_1"/></svg>';
      }
      
      loadingDiv.style.display = 'block';
      console.log('DEBUG: Loading spinner should now be visible with official animation');
      
      // Auto-scroll to status section
      showTab('status');
    } else {
      console.log('DEBUG: Missing elements - loadingDiv:', !!loadingDiv, 'loadingMessage:', !!loadingMessage, 'spinnerDiv:', !!spinnerDiv);
    }
  }

  function hideStatusLoading() {
    const loadingDiv = document.getElementById('status-loading');
    if (loadingDiv) {
      loadingDiv.style.display = 'none';
    }
  }

  function runAutoStartSetup() {
    console.log('DEBUG: runAutoStartSetup called');
    
    // Auto-scroll to Status section immediately to show we're starting
    showTab('status');
    showStatusLoading('Starting complete auto-unlock setup...');
    
    // Use updateStatus instead of setStatus to avoid hiding the spinner
    document.getElementById('statusOutput').textContent = 'DEBUG: Function called, starting validation...\n';
    
    // Validate encryption key input using shared component
    const validationError = validateEncryptionKeyInput('autostart');
    console.log('DEBUG: Validation result:', validationError);
    if (validationError) {
      hideStatusLoading();
      setStatus('Error: ' + validationError);
      return;
    }
    
    updateStatus('DEBUG: Validation passed, continuing...');

    const backupLocation = document.getElementById('backupLocation').value;
    const dryRun = document.getElementById('dryRun').value;
    console.log('DEBUG: backupLocation:', backupLocation, 'dryRun:', dryRun);

    // Update the status output without hiding the loading spinner
    updateStatus('Starting complete auto-unlock setup...\nThis will backup headers, refresh hardware key, and enable auto-unlock.\nExecuting LUKS management script, please wait...');
    
    console.log('DEBUG: Status set, preparing form data');

    // Convert backupLocation to the format expected by the backend
    const backupHeaders = backupLocation === 'download' ? 'download' : 'yes';

    // Prepare data using Unraid's pattern (no FormData, use base64 for files)
    const keyType = document.getElementById('keyType_autostart').value;
    console.log('DEBUG: keyType:', keyType);
    
    const postData = {
      keyType: keyType,
      backupHeaders: backupHeaders,
      dryRun: dryRun
    };
    
    if (keyType === 'passphrase') {
      const passphrase = document.getElementById('passphrase_autostart').value;
      console.log('DEBUG: Using passphrase, length:', passphrase.length);
      postData.passphrase = passphrase;
    } else {
      const keyfileInput = document.getElementById('keyfile_autostart');
      console.log('DEBUG: Using keyfile, files:', keyfileInput.files);
      if (keyfileInput.files && keyfileInput.files[0]) {
        console.log('DEBUG: File selected:', keyfileInput.files[0].name, 'Size:', keyfileInput.files[0].size);
        
        // Add ZIP password for keyfile users
        const zipPassword = document.getElementById('zipPassword_autostart').value;
        postData.zipPassword = zipPassword;
        console.log('DEBUG: ZIP password included for keyfile user');
        
        // Convert file to base64 (Unraid pattern)
        const reader = new FileReader();
        reader.onload = function(e) {
          const base64Data = e.target.result; // This includes 'data:application/octet-stream;base64,'
          postData.keyfileData = base64Data;
          
          // Add CSRF token
          console.log('DEBUG: Using CSRF token:', csrf_token);
          if (csrf_token) {
            postData.csrf_token = csrf_token;
          }
          
          console.log('DEBUG: Starting AJAX request with base64 keyfile');
          makeAjaxRequest(postData);
        };
        reader.readAsDataURL(keyfileInput.files[0]);
        return; // Exit here, the request will be made in the reader callback
      } else {
        console.log('DEBUG: No file selected!');
        setStatus('Error: No keyfile selected');
        return;
      }
    }
    
    // Add CSRF token for passphrase requests
    console.log('DEBUG: Using CSRF token:', csrf_token);
    if (csrf_token) {
      postData.csrf_token = csrf_token;
    } else {
      console.log('WARNING: No CSRF token available');
    }

    console.log('DEBUG: Starting AJAX request to /plugins/luks-key-management/scripts/run_luks_script.php');
    makeAjaxRequest(postData);
  }
  
  function makeAjaxRequest(postData) {
    $.ajax({
      url: '/plugins/luks-key-management/scripts/run_luks_script.php',
      type: 'POST',
      data: postData,
      beforeSend: function(xhr) {
        console.log('DEBUG: AJAX request starting...');
        updateStatus('DEBUG: AJAX request initiated...');
      },
      success: function(data) {
        console.log('DEBUG: AJAX success, response length:', data.length);
        console.log('DEBUG: Response data:', data);
        setStatus(data);
        
        // Use shared download detection function
        const finalBackupLocation = document.getElementById('backupLocation').value;
        const finalDryRun = document.getElementById('dryRun').value;
        handleDownloadDetection(data, finalBackupLocation, finalDryRun);
      },
      error: function(xhr, status, error) {
        console.log('DEBUG: AJAX error - Status:', status, 'Error:', error);
        console.log('DEBUG: XHR object:', xhr);
        setStatus('Error: AJAX failed - Status: ' + status + ', Error: ' + error + '\nCheck browser console for more details.');
      }
    });
  }

  function downloadBackupFile(filename) {
    // Create direct download link - file is accessible via plugin downloads directory
    const downloadUrl = '/plugins/luks-key-management/downloads/' + filename;
    
    // Create a temporary anchor element to trigger download
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = filename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Update status to inform user
    updateStatus('\nBackup file download initiated. Check your browser\'s download folder.');
    
    // Clean up the temporary file after a delay
    setTimeout(function() {
      fetch('/plugins/luks-key-management/scripts/cleanup_download.php', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'filename=' + encodeURIComponent(filename)
      });
    }, 5000); // 5 second delay to ensure download completes
  }

  function runGoCommand() {
    const action = document.getElementById('goAction').value;

    // Auto-scroll to Status section to show operation progress
    showTab('status');
    showStatusLoading('Configuring startup script...');
    updateStatus('Starting go file configuration...\nExecuting startup script configuration, please wait...');

    console.log('DEBUG: CSRF token for go command:', csrf_token);
    
    const postData = { action: action };
    if (csrf_token) {
      postData.csrf_token = csrf_token;
    } else {
      console.log('WARNING: No CSRF token available for go command');
    }
    
    $.post('/plugins/luks-key-management/scripts/run_go_script.php', postData, function(data) {
      setStatus(data);
    }).fail(function() {
      setStatus('Error: Failed to execute the go file script. Check browser console for more details.');
    });
  }

  function runHeadersBackup() {
    // Validate encryption key input using shared component
    const validationError = validateEncryptionKeyInput('headers');
    if (validationError) {
      setStatus('Error: ' + validationError);
      return;
    }

    const backupLocation = document.getElementById('headersBackupLocation').value;

    // Auto-scroll to Status section to show operation progress
    showTab('status');
    showStatusLoading('Backing up LUKS headers...');
    updateStatus('Starting LUKS headers backup operation...\nExecuting LUKS headers backup script, please wait...');

    // Use the same backend but with headers-only flags
    const backupMode = backupLocation === 'download' ? 'download' : 'yes';
    const keyType = document.getElementById('keyType_headers').value;
    
    // Prepare data using the same pattern as Auto Start (which works)
    const postData = {
      keyType: keyType,
      backupHeaders: backupMode,
      dryRun: 'no', // Headers backup is always live
      headersOnly: 'true' // Flag to indicate this is headers-only operation
    };
    
    if (keyType === 'passphrase') {
      const passphrase = document.getElementById('passphrase_headers').value;
      postData.passphrase = passphrase;
      
      // Add CSRF token
      if (csrf_token) {
        postData.csrf_token = csrf_token;
      }
      
      // Make request directly for passphrase
      makeHeadersAjaxRequest(postData, backupLocation);
    } else {
      const keyfileInput = document.getElementById('keyfile_headers');
      if (keyfileInput.files && keyfileInput.files[0]) {
        // Add ZIP password for keyfile users
        const zipPassword = document.getElementById('zipPassword_headers').value;
        postData.zipPassword = zipPassword;
        console.log('DEBUG: ZIP password included for headers keyfile user');
        
        // Convert file to base64 (same pattern as Auto Start)
        const reader = new FileReader();
        reader.onload = function(e) {
          const base64Data = e.target.result;
          postData.keyfileData = base64Data;
          
          // Add CSRF token
          if (csrf_token) {
            postData.csrf_token = csrf_token;
          }
          
          makeHeadersAjaxRequest(postData, backupLocation);
        };
        reader.readAsDataURL(keyfileInput.files[0]);
        return;
      } else {
        setStatus('Error: No keyfile selected');
        return;
      }
    }
  }
  
  function makeHeadersAjaxRequest(postData, backupLocation) {
    $.ajax({
      url: '/plugins/luks-key-management/scripts/run_luks_script.php',
      type: 'POST',
      data: postData,
      success: function(data) {
        setStatus(data);
        
        // Check if we need to download a backup file
        if (backupLocation === 'download') {
          const downloadMatch = data.match(/DOWNLOAD_READY: (.+)/);
          if (downloadMatch) {
            const downloadPath = downloadMatch[1];
            const filename = downloadPath.split('/').pop();
            downloadBackupFile(filename);
          }
        }
      },
      error: function() {
        setStatus('Error: Failed to execute the LUKS headers backup script. Check browser console for more details.');
      }
    });
  }

  function runEncryptionInfo() {
    // Validate encryption key input using shared component
    const validationError = validateEncryptionKeyInput('encinfo');
    if (validationError) {
      setStatus('Error: ' + validationError);
      return;
    }

    const detailLevel = document.getElementById('detailLevel').value;
    const keyType = document.getElementById('keyType_encinfo').value;

    // Auto-scroll to Status section to show operation progress
    showTab('status');
    showStatusLoading('Analyzing LUKS encryption...');
    updateStatus('Starting encryption analysis...\nAnalyzing LUKS encrypted drives and slot configurations, please wait...');

    // Prepare data using the same pattern as Auto Start (which works)
    const postData = {
      keyType: keyType,
      detailLevel: detailLevel
    };
    
    if (keyType === 'passphrase') {
      const passphrase = document.getElementById('passphrase_encinfo').value;
      postData.passphrase = passphrase;
      
      // Add CSRF token with debug output
      console.log('DEBUG: CSRF token available:', csrf_token);
      console.log('DEBUG: CSRF token length:', csrf_token ? csrf_token.length : 'undefined');
      console.log('DEBUG: CSRF token type:', typeof csrf_token);
      if (csrf_token && csrf_token.length > 0) {
        postData.csrf_token = csrf_token;
        console.log('DEBUG: CSRF token added to postData');
      } else {
        console.log('WARNING: CSRF token is empty or undefined!');
      }
      
      // Make request directly for passphrase
      makeEncryptionInfoAjaxRequest(postData);
    } else {
      const keyfileInput = document.getElementById('keyfile_encinfo');
      if (keyfileInput.files && keyfileInput.files[0]) {
        // Convert file to base64 (same pattern as Auto Start)
        const reader = new FileReader();
        reader.onload = function(e) {
          const base64Data = e.target.result;
          postData.keyfileData = base64Data;
          
          // Add CSRF token with debug output
          console.log('DEBUG: CSRF token available (keyfile):', csrf_token);
          console.log('DEBUG: CSRF token length (keyfile):', csrf_token ? csrf_token.length : 'undefined');
          if (csrf_token && csrf_token.length > 0) {
            postData.csrf_token = csrf_token;
            console.log('DEBUG: CSRF token added to postData (keyfile)');
          } else {
            console.log('WARNING: CSRF token is empty or undefined (keyfile)!');
          }
          
          makeEncryptionInfoAjaxRequest(postData);
        };
        reader.readAsDataURL(keyfileInput.files[0]);
        return;
      } else {
        setStatus('Error: No keyfile selected');
        return;
      }
    }
  }
  
  function makeEncryptionInfoAjaxRequest(postData) {
    console.log('DEBUG: About to send AJAX request with data:', postData);
    console.log('DEBUG: Data keys:', Object.keys(postData));
    console.log('DEBUG: CSRF token in postData:', postData.csrf_token);
    
    // Try the exact same AJAX pattern as the working Auto Start function
    $.ajax({
      url: '/plugins/luks-key-management/scripts/run_encryption_info.php',
      type: 'POST',
      data: postData,
      beforeSend: function(xhr) {
        console.log('DEBUG: AJAX request starting with data keys:', Object.keys(postData));
        console.log('DEBUG: AJAX CSRF token being sent:', postData.csrf_token);
      },
      success: function(data) {
        setStatus(data);
      },
      error: function() {
        setStatus('Error: Failed to execute encryption analysis. Check browser console for more details.');
      }
    });
  }

  function downloadEncryptionInfo() {
    // Validate encryption key input using shared component
    const validationError = validateEncryptionKeyInput('encinfo');
    if (validationError) {
      setStatus('Error: ' + validationError);
      return;
    }

    const detailLevel = document.getElementById('detailLevel').value;
    const keyType = document.getElementById('keyType_encinfo').value;

    // Auto-scroll to Status section to show operation progress
    showTab('status');
    showStatusLoading('Preparing encryption analysis download...');
    updateStatus('Preparing encryption analysis for download...\nGenerating encrypted analysis file, please wait...');

    // Prepare data using the same pattern as Auto Start (which works)
    const postData = {
      keyType: keyType,
      detailLevel: detailLevel
    };
    
    if (keyType === 'passphrase') {
      const passphrase = document.getElementById('passphrase_encinfo').value;
      postData.passphrase = passphrase;
      
      // Add CSRF token
      if (csrf_token) {
        postData.csrf_token = csrf_token;
      }
      
      // Make request directly for passphrase
      makeEncryptionDownloadAjaxRequest(postData);
    } else {
      const keyfileInput = document.getElementById('keyfile_encinfo');
      if (keyfileInput.files && keyfileInput.files[0]) {
        // Convert file to base64 (same pattern as Auto Start)
        const reader = new FileReader();
        reader.onload = function(e) {
          const base64Data = e.target.result;
          postData.keyfileData = base64Data;
          
          // Add CSRF token
          if (csrf_token) {
            postData.csrf_token = csrf_token;
          }
          
          makeEncryptionDownloadAjaxRequest(postData);
        };
        reader.readAsDataURL(keyfileInput.files[0]);
        return;
      } else {
        setStatus('Error: No keyfile selected');
        return;
      }
    }
  }
  
  function makeEncryptionDownloadAjaxRequest(postData) {
    $.ajax({
      url: '/plugins/luks-key-management/scripts/run_encryption_download.php',
      type: 'POST',
      data: postData,
      success: function(data) {
        setStatus(data);
        
        // Check if we need to download the analysis file
        const downloadMatch = data.match(/DOWNLOAD_READY: (.+)/);
        if (downloadMatch) {
          const downloadPath = downloadMatch[1];
          const filename = downloadPath.split('/').pop();
          downloadAnalysisFile(filename);
        }
      },
      error: function() {
        setStatus('Error: Failed to generate encryption analysis download. Check browser console for more details.');
      }
    });
  }

  function downloadAnalysisFile(filename) {
    // Create direct download link - file is accessible via plugin downloads directory
    const downloadUrl = '/plugins/luks-key-management/downloads/' + filename;
    
    // Create a temporary anchor element to trigger download
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = filename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Update status to inform user
    updateStatus('\nEncryption analysis download initiated. Check your browser\'s download folder.');
    
    // Clean up the temporary file after a delay
    setTimeout(function() {
      fetch('/plugins/luks-key-management/scripts/cleanup_download.php', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'filename=' + encodeURIComponent(filename)
      });
    }, 5000); // 5 second delay to ensure download completes
  }

  function goToDiskSettings() {
    console.log('DEBUG: goToDiskSettings function called');
    
    // Get current protocol, hostname, and port from the current page
    const currentUrl = window.location;
    const baseUrl = `${currentUrl.protocol}//${currentUrl.host}`;
    const diskSettingsUrl = `${baseUrl}/Settings/DiskSettings`;
    
    console.log('DEBUG: Opening URL:', diskSettingsUrl);
    
    // Open Disk Settings in a new tab
    const newWindow = window.open(diskSettingsUrl, '_blank');
    
    console.log('DEBUG: New window object:', newWindow);
    
    // Wait for page to load, then scroll to encryption section
    if (newWindow) {
      const checkForLoad = setInterval(function() {
        try {
          console.log('DEBUG: Checking page state:', newWindow.document.readyState);
          if (newWindow.document.readyState === 'complete') {
            clearInterval(checkForLoad);
            console.log('DEBUG: Page loaded, attempting to scroll to encryption section');
            
            // Small delay to ensure content is fully rendered
            setTimeout(function() {
              try {
                // Try multiple selectors to find the encryption section
                const selectors = [
                  '.title .fa-key',           // Original selector
                  '.fa-key',                  // Just the key icon
                  '[class*="fa-key"]',        // Any element with fa-key in class
                  'span:contains("encryption")', // Text-based search
                  'span:contains("Change encryption")', // More specific text
                  'h3:contains("Change encryption")', // Different heading level
                  '.title:contains("encryption")', // Title containing encryption
                ];
                
                let encryptionElement = null;
                let usedSelector = '';
                
                for (const selector of selectors) {
                  console.log('DEBUG: Trying selector:', selector);
                  
                  if (selector.includes(':contains')) {
                    // Handle text-based selectors manually
                    const elements = newWindow.document.querySelectorAll(selector.split(':')[0]);
                    for (const el of elements) {
                      const searchText = selector.match(/contains\("([^"]+)"\)/)[1];
                      if (el.textContent.toLowerCase().includes(searchText.toLowerCase())) {
                        encryptionElement = el;
                        usedSelector = selector;
                        break;
                      }
                    }
                  } else {
                    encryptionElement = newWindow.document.querySelector(selector);
                  }
                  
                  if (encryptionElement) {
                    usedSelector = selector;
                    console.log('DEBUG: Found element with selector:', usedSelector, encryptionElement);
                    break;
                  }
                }
                
                if (encryptionElement) {
                  // Try to find the best parent element to scroll to
                  let scrollTarget = encryptionElement;
                  if (usedSelector !== '.title .fa-key') {
                    // If we didn't find the original title, try to find a good parent
                    scrollTarget = encryptionElement.closest('.title') || 
                                 encryptionElement.closest('h3') || 
                                 encryptionElement.closest('div') || 
                                 encryptionElement;
                  }
                  
                  scrollTarget.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                  });
                  console.log('DEBUG: Scrolled to encryption section using element:', scrollTarget);
                } else {
                  console.log('DEBUG: Could not find encryption section with any selector');
                  
                  // Debug: Let's see what's actually on the page
                  console.log('DEBUG: Analyzing page structure...');
                  
                  // Look for all headings
                  const headings = newWindow.document.querySelectorAll('h1, h2, h3, h4, h5, h6');
                  console.log('DEBUG: Found headings:', Array.from(headings).map(h => h.textContent.trim()));
                  
                  // Look for all elements with "title" class
                  const titles = newWindow.document.querySelectorAll('.title');
                  console.log('DEBUG: Found .title elements:', Array.from(titles).map(t => t.textContent.trim()));
                  
                  // Look for any FontAwesome icons
                  const icons = newWindow.document.querySelectorAll('[class*="fa-"]');
                  console.log('DEBUG: Found FontAwesome icons:', Array.from(icons).map(i => i.className));
                  
                  // Look for elements containing "encrypt" anywhere in text
                  const encryptElements = [];
                  const walker = newWindow.document.createTreeWalker(
                    newWindow.document.body,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                  );
                  
                  let node;
                  while (node = walker.nextNode()) {
                    if (node.textContent.toLowerCase().includes('encrypt')) {
                      encryptElements.push({
                        text: node.textContent.trim(),
                        parent: node.parentElement.tagName + (node.parentElement.className ? '.' + node.parentElement.className : '')
                      });
                    }
                  }
                  console.log('DEBUG: Found elements with "encrypt" text:', encryptElements);
                  
                  // Fallback: try more specific selectors for the encryption section
                  const fallbackSelectors = [
                    'form[onsubmit*="prepareForm"]',  // The encryption form
                    'input[name="oldtext"]',          // Encryption input field
                    'input[name="newtext"]',          // New encryption input
                    'select[name="oldinput"]',        // Encryption input type selector
                    'dt:contains("Change encryption")', // Any dt with "Change encryption"
                    'label:contains("encryption")',  // Any label with encryption
                  ];
                  
                  let scrollTarget = null;
                  for (const selector of fallbackSelectors) {
                    console.log('DEBUG: Trying fallback selector:', selector);
                    
                    if (selector.includes(':contains')) {
                      // Handle text-based selectors
                      const baseSelector = selector.split(':')[0];
                      const searchText = selector.match(/contains\("([^"]+)"\)/)[1];
                      const elements = newWindow.document.querySelectorAll(baseSelector);
                      
                      for (const el of elements) {
                        if (el.textContent.toLowerCase().includes(searchText.toLowerCase())) {
                          scrollTarget = el;
                          console.log('DEBUG: Found fallback target with text search:', el);
                          break;
                        }
                      }
                    } else {
                      scrollTarget = newWindow.document.querySelector(selector);
                      if (scrollTarget) {
                        console.log('DEBUG: Found fallback target with direct selector:', scrollTarget);
                      }
                    }
                    
                    if (scrollTarget) break;
                  }
                  
                  if (scrollTarget) {
                    // Try to find a good parent element to scroll to
                    const betterTarget = scrollTarget.closest('form') || 
                                       scrollTarget.closest('.title') || 
                                       scrollTarget.closest('div') || 
                                       scrollTarget;
                    
                    betterTarget.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    console.log('DEBUG: Fallback scroll successful to:', betterTarget.tagName, betterTarget.className);
                  } else {
                    console.log('DEBUG: No fallback targets found, trying generic text search');
                    
                    // Last resort: scan for specific encryption elements
                    const encryptionElements = [
                      // Look for specific form elements related to encryption
                      'input[type="password"]',
                      'input[name*="luks"]',
                      'input[name*="encrypt"]', 
                      'select[name*="encrypt"]',
                      'form[method="POST"]',
                    ];
                    
                    let foundElement = null;
                    for (const selector of encryptionElements) {
                      const elements = newWindow.document.querySelectorAll(selector);
                      for (const el of elements) {
                        // Check if this element or its nearby text mentions encryption
                        const context = el.closest('form') || el.parentElement;
                        if (context && context.textContent.toLowerCase().includes('encrypt')) {
                          foundElement = context;
                          console.log('DEBUG: Found encryption element via selector:', selector, el);
                          break;
                        }
                      }
                      if (foundElement) break;
                    }
                    
                    if (foundElement) {
                      foundElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                      console.log('DEBUG: Scrolled to encryption form context:', foundElement.tagName, foundElement.className);
                    } else {
                      // Final fallback: look for visible elements (not HTML/BODY) with encrypt text
                      const allElements = newWindow.document.querySelectorAll('form, div, dl, dt, dd, p, span, label');
                      for (const el of allElements) {
                        if (el.textContent && 
                            el.textContent.toLowerCase().includes('encrypt') && 
                            el.offsetHeight > 0 && 
                            el.tagName !== 'HTML' && 
                            el.tagName !== 'BODY') {
                          el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                          console.log('DEBUG: Final fallback scroll to:', el.tagName, el.className, el.textContent.substring(0, 50));
                          break;
                        }
                      }
                    }
                  }
                }
              } catch (e) {
                // Ignore cross-origin errors if any
                console.log('DEBUG: Could not scroll to encryption section due to browser restrictions:', e);
              }
            }, 500);
          }
        } catch (e) {
          // Ignore cross-origin errors during loading
        }
      }, 100);
      
      // Clean up interval after 10 seconds to avoid memory leaks
      setTimeout(function() {
        clearInterval(checkForLoad);
      }, 10000);
    }
  }

  // Shared encryption key input component functions
  function toggleKeyInput(tabname) {
    const keyType = document.getElementById('keyType_' + tabname).value;
    const passphraseSection = document.getElementById('passphraseSection_' + tabname);
    const keyfileSection = document.getElementById('keyfileSection_' + tabname);
    
    if (keyType === 'passphrase') {
      passphraseSection.style.display = 'block';
      keyfileSection.style.display = 'none';
      // Clear keyfile input when switching to passphrase
      const keyfileInput = document.getElementById('keyfile_' + tabname);
      if (keyfileInput) keyfileInput.value = '';
    } else {
      passphraseSection.style.display = 'none'; 
      keyfileSection.style.display = 'block';
      // Clear passphrase input when switching to keyfile
      const passphraseInput = document.getElementById('passphrase_' + tabname);
      if (passphraseInput) passphraseInput.value = '';
    }
  }

  function togglePasswordVisibility(tabname) {
    const passphraseInput = document.getElementById('passphrase_' + tabname);
    const checkbox = event.target;
    
    if (checkbox.checked) {
      passphraseInput.type = 'text';
    } else {
      passphraseInput.type = 'password';
    }
  }

  function validateKeyfileSize(fileInput, tabname) {
    const maxSize = 8 * 1024 * 1024; // 8 MiB
    const file = fileInput.files[0];
    
    if (file && file.size > maxSize) {
      alert('Keyfile exceeds 8 MiB limit (Unraid standard). Please select a smaller file.');
      fileInput.value = ''; // Clear the input
      return false;
    }
    return true;
  }

  function validateEncryptionKeyInput(tabname) {
    const keyType = document.getElementById('keyType_' + tabname).value;
    
    if (keyType === 'passphrase') {
      const passphrase = document.getElementById('passphrase_' + tabname).value;
      if (!passphrase) {
        return 'Please enter your encryption passphrase.';
      }
      if (passphrase.length > 512) {
        return 'Passphrase exceeds 512 character limit (Unraid standard).';
      }
    } else {
      const keyfileInput = document.getElementById('keyfile_' + tabname);
      if (!keyfileInput.files || !keyfileInput.files[0]) {
        return 'Please select your encryption keyfile.';
      }
      
      // Validate ZIP password for keyfile users (only for autostart and headers tabs)
      if (tabname === 'autostart' || tabname === 'headers') {
        const zipPassword = document.getElementById('zipPassword_' + tabname).value;
        if (!zipPassword) {
          return 'Please enter a password to encrypt the backup ZIP file.';
        }
        if (zipPassword.length < 4) {
          return 'ZIP password must be at least 4 characters long.';
        }
        if (zipPassword.length > 512) {
          return 'ZIP password exceeds 512 character limit.';
        }
      }
    }
    return null; // Valid
  }

  // Shared download detection function - checks output for DOWNLOAD_READY and triggers download
  function handleDownloadDetection(data, backupLocation, dryRun) {
    console.log('DEBUG: Checking download - backupLocation:', backupLocation, 'dryRun:', dryRun);
    if (backupLocation === 'download' && dryRun === 'no') {
      // Look for download ready indicator in the output
      console.log('DEBUG: Looking for DOWNLOAD_READY in output...');
      const downloadMatch = data.match(/DOWNLOAD_READY: (\/usr\/local\/emhttp\/plugins\/luks-key-management\/downloads\/[^D\s]+\.zip)/);
      console.log('DEBUG: Download match result:', downloadMatch);
      if (downloadMatch) {
        const downloadPath = downloadMatch[1].trim();
        const filename = downloadPath.split('/').pop();
        console.log('DEBUG: Starting download for file:', filename);
        console.log('DEBUG: Full download path:', downloadPath);
        console.log('DEBUG: Raw matched string:', downloadMatch[1]);
        downloadBackupFile(filename);
      } else {
        console.log('DEBUG: No DOWNLOAD_READY found in output');
      }
    } else {
      console.log('DEBUG: Download not triggered - conditions not met');
    }
  }

  // Function to toggle ZIP password visibility
  function togglePasswordVisibility(tabname) {
    const passwordInput = document.getElementById('zipPassword_' + tabname);
    const checkbox = document.getElementById('showZipPassword_' + tabname);
    
    if (checkbox.checked) {
      passwordInput.type = 'text';
    } else {
      passwordInput.type = 'password';
    }
  }

</script>